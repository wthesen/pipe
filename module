#Schlumberger Private
#Copyright (c) 2018 Schlumberger

"""
    The pipesim module maintains the high level classes and methods for the
    PIPESIM Python Toolkit. This includes aspects such as the Model() class
    for creating a session with a PIPESIM model as well as the static classes
    that enumerate the options that are available.
"""

# Standard functionality
import logging
import urllib
import six
import os
from contextlib import contextmanager
from typing import Any, Dict, List, Optional
from collections import defaultdict

# PIPESIM model functionality
from pandas import DataFrame

# From the manta low level API
from manta.api import create_pipesim_session
from manta.server.server_proxy import PipesimServerError
from manta.server.manager import PipesimManager

# From the sixgill high level API core
from sixgill.definitions import Constants, Units, Parameters, ModelComponents, Tasks, NAN
from sixgill.core.mapping import ParameterError
from sixgill.core.mapping_almanac import ParameterMappingAlmanac
from sixgill.core.metadata import open_metadata
from sixgill.core.model_context import AbstractModelContext, ContextError
from sixgill.core.model_fact_list import ModelFactList
from sixgill.core.catalog import NodeCatalog
from sixgill.core.resources import IPRModelType, ModelClasses, SchemaNodes, NODE_REFRESH_REQUIRED
from sixgill.core import getset
from sixgill.core.connection import connect, disconnect, connections, get_connections, get_model_context
from sixgill.core.convert import convert
from sixgill.core.elevation import _get_elevation, _get_elevations
from sixgill.core.blackoil_profile import BlackOilViscosityProfile, BlackOilEmulsionProfile
from sixgill.core.well_profile import WellTrajectory, BoreholeGeothermalSurvey, CompletionTestPointTable, update_well_context
from sixgill.core.flowline_profile import FlowlineGeometryProfile, FlowlineGeothermalProfile
from sixgill.core.coat_profile import PipeCoatingProfile
from sixgill.core.relative_permeability import RelativePermeabilityData
from sixgill.core.pq_curve import PQCurve
from sixgill.core.find import find_contexts, _find_catalog_node_entries
from sixgill.core.delete import _delete
from sixgill.core.add import _add, _copy
from sixgill.core.import_export_well import import_well, export_well, export_wells, import_wells
from sixgill.core.open_ui import open_ui
from sixgill.core.engine_file import generate, compute_operation_context
from sixgill.core.simulation_result_handler import ResultVariableCache
from sixgill.core.net_sim_simulation import (get_netsim_conditions, set_netsim_conditions, 
                                             run_network_simulation, start_network_simulation, reset_netsim_conditions,
                                             get_netsim_constraints, delete_netsim_constraints)

from sixgill.core.get_or_create_operation import (get_or_create_network_sim_node,get_or_create_na_operation, get_or_create_gldiagnostics_sim_node, 
                                                  get_or_create_pt_sim_node,get_or_create_wc_sim_node, get_or_create_sa_sim_node, get_single_branch_task_producer)

from sixgill.core.simulation_types import SimulationTypes
from sixgill.core.simulations import (_reset_nodal_conditions,
_get_nodal_inlet_conditions, _get_pt_conditions, _set_pt_conditions, _reset_pt_sim_conditions,
_get_operation_sim_calc_variables, _get_na_conditions,
_set_wc_conditions, _get_wc_conditions, _run_wc_simulation, _start_wc_simulation,
_set_na_conditions, _run_ptprofile_simulation,
_start_ptprofile_simulation, _run_na_simulation, _start_na_simulation,
 _set_sa_conditions, _get_sa_conditions, _run_systemanalysis_simulation,
_start_systemanalysis_simulation, _reset_sa_sim_conditions,
_get_gldiagnostics_conditions, _set_gldiagnostics_conditions, _reset_gldiagnostics_conditions, 
  _run_gldiagnostics_simulation, _start_gldiagnostics_simulation)

from sixgill.core.sensitivities import _get_possible_task_sens_variables

from sixgill.abstract_simulation import AbstractNetworkSimulation, AbstractSingleBranchSimulation
from sixgill.network_optimizer_simulation import NetworkOptimizerSimulation
from sixgill.vfp_tables_simulation import VfpTablesOperationSimulation
from sixgill.core.validations_utility import _validate_items, _generate_validation_issues
from sixgill.validation import ValidationIssue
from sixgill.core.mapping_dictionaries import MODEL_COMPONENTS_TO_CLASSES_DICT
from sixgill.core.production_data_update_status import production_data_update_status, ReportMessageTypes, _can_report_error, _can_report_warning, _can_report_information

from sixgill.core.ipr_points import get_ipr_points_for_completion, IprPoints
from sixgill.component import Component
from sixgill.core.fcv_get_set import FcvGetSetValues

# Logging functionality
_logger = logging.Logger(__name__)

NEW_WORKSPACE_PATH = os.path.join(os.path.dirname(os.path.realpath(__file__)), 'New workspace template.pips')

class Model(object):
    """
        The Model() class defines a session for working with a PIPESIM
        model. It maintains the connection details of the session while the
        Manta module performs the actual interaction with the
        PIPESIM model. Users should open a PIPESIM model using the
        Model.open() which takes care of handling the low level Manta
        calls.

        Parameters
        ----------
        pipesim_session : manta.server.manager.PipesimManager
            The pipesim_session object from the Manta module.
        model_file : str
            The full folder and filename of the pipesim file.
        unit_system  : str
            The engineering units system being used for reading and writing the
            values, as defined by the Units static class.

        Returns
        -------
        Model
            The PIPESIM model session object.

        Examples
        --------

        >>> mymodel=Model.open("C:/ProjectX/Models/PIPESIM/ProjectXModel.pips")
    """

    def __init__(self, pipesim_session, model_file, unit_system):
        """ Initialize the PIPESIM model interface """

        # The session is not a valid pipesim session - kick them out now
        if (not pipesim_session):
            raise ValueError("Model initialization error.")

        self._model_file = model_file
        self._session = pipesim_session
        self._metadata = open_metadata(pipesim_session.web_api.graph)
        self._almanac = ParameterMappingAlmanac.from_metadata(self._metadata)
        self._catalog = NodeCatalog(pipesim_session, self._metadata, self._almanac.all_class_ids)
        self._unit_system = unit_system
        self._in_memory_results = True
        # make sure we clear out the variable meta when open a new session, otherwise the variable
        # may not get cached from server
        ResultVariableCache.clear()
        self._is_open = True
        self._tasks = None
        self._ui_unit_system = ''
        self._find_ui_unit_system()
        model = self._get_web_api_model()

    def __validate(self,
             context: Optional[str] = None,
             component: Optional[str] = None)-> List[ValidationIssue]:
        
        if context is not None or component is not None:
            class_id = None
            if(component is not None):
                class_id = MODEL_COMPONENTS_TO_CLASSES_DICT.get(component)
            merged_context = getset.compute_context(root_context=self.context,
                                                     context=context,
                                                     component=component)
            if class_id is not None:
                filtered_entries = [entry for entry in self._catalog.lookup_entries_by_context(merged_context, component=component) if entry.class_id == class_id and entry._model_component]
            else:
                filtered_entries = [entry for entry in self._catalog.lookup_entries_by_context(merged_context, component=component) if entry.name and entry._model_component]

            ret = _validate_items(self, filtered_entries, False)
            return ret

        response = self.api.Validate.get_validate()
        ret = _generate_validation_issues(response, self)
        return ret
    
    def _find_ui_unit_system(self):
        global_catalogs = self._catalog.lookup_entries_by_class_ids([ModelClasses.GLOBALCATALOG])
        if global_catalogs:
            global_catalog = self._catalog.get_node_by_id(global_catalogs[0].node_id)
            if global_catalog.Name == Units.FIELD or global_catalog.Name == Units.METRIC or global_catalog.Name == Units.SI:
                self._ui_unit_system = global_catalog.Name
            else:
                self._ui_unit_system = "Custom"


    def _get_web_api_model(self):
        models = self._catalog.lookup_entries_by_class_ids([ModelClasses.MODEL])
        if not models:
            _logger.log("Web API model is not retrieved properly.")
            return
        return self._catalog.get_node_by_id(models[0].node_id)


    def __add_pipe_to_flowline__(self,fluid_name, prop_dict:defaultdict):
        result = self._catalog.lookup_entries_by_name_and_class_ids(fluid_name, ModelClasses.FLOWLINE)
        if not result or len(result) > 1:
            raise RuntimeError( "Multiple/No flowlines with the same name.")
        entry = result[0]
        empty_dict = {}
        #get the id of the Section(section is a link property on flowline, poiting to corresponding Pipe)
        pipe_node_id = entry.json_dict.get(SchemaNodes.SECTION, empty_dict).get(SchemaNodes.ID)
        if not pipe_node_id:
            raise RuntimeError("Cannot find the pipe id for flowline")
        # get the node pipe entry from the catalog
        pipe_entry = self._catalog.lookup_entry_by_id(pipe_node_id)
        if not pipe_entry:
            raise RuntimeError("Cannot find the pipe for flowline")
        #get All pipe properties
        pipe_values = getset.get_all_values_by_entry(self._almanac, self._catalog, self._session, False, pipe_entry)

        for k, pipe_prop_dict in pipe_values.items():
            for prop_name,value in pipe_prop_dict.items():
                if prop_name == 'Name':
                    continue
                prop_dict[prop_name] = value

    @property
    def is_open(self):
        """  Whether the pipesim model is open (True) or not (False) """
        return self._is_open

    @property
    def api(self):
        """ The low level Manta library API """
        if (self._session is None):
            return None
        return self._session.web_api

    @property
    def filename(self):
        """ The model file name and path """
        return self._model_file


    @property
    def session(self):
        """ The model session """
        return self._session
            
    @staticmethod
    def update_data_context(filename: str, model_type: str, save_as: str, 
                            model_update_url: Optional[str]=None, data_partition: Optional[str]=None, token: Optional[str]=None, appkey: Optional[str]=None,
                            report_messages_of_type: Optional[ReportMessageTypes]=ReportMessageTypes.ALL,
                            production_study_name: Optional[str]=None,
                            max_retries: Optional[str]=None,
                            base_retry_time: Optional[str]=None,
                            max_time: Optional[str]=None,
                            jitter_factor: Optional[str]=None,
                            )->production_data_update_status:
        """
        Updates the model with the latest production data

        Note:
            base_sleep_time = min(max_time, base_retry_time * retry_number) 
            sleep_time = base_sleep_time +/- random(jitter_factor * base_sleep_time)

        Args:
            filename (str): Full path to the pips file to be updated
            model_type (str): Type of the model: [pipesim-well, pipesim network]
            save_as (str): Full path to where to save the updated model
            model_update_url (str): a file or url address of the service providing the operational data
            data_partition (str): data partition
            token (str): access token
            appkey (Optional[str]): appKey
            report_messages_of_type: indicate what type of messages to report(default is all types)
            production_study_name (Optional[str]): name of the production study
            max_retries (Optional[str]): maximum number of retries when HTTP request is failed
            base_retry_time (Optional[str]): base time used to calculate sleep time for each retry
            max_time (Optional[str]): maximum base sleep time
            jitter_factor (Optional[str]): jitter factor


        Returns:
            [production_data_update_status]: A class containing lists of messages and properties.
        """
        
        #open the model
        model = Model.open(filename)
        
        post_payload = {
            'Modeltype': model_type,
            'ProductionStudyName': production_study_name,
            'ModelUpdateUrl': model_update_url,
            'Partition': data_partition,
            'AppKey': appkey,
            'Token': token,
            'ReportErrors': _can_report_error(report_messages_of_type),
            'ReportWarnings': _can_report_warning(report_messages_of_type),
            'ReportInfo': _can_report_information(report_messages_of_type),
            'MaxRetries': max_retries,
            'MaxTime': max_time,
            'BaseRetryTime': base_retry_time,
            'JitterFactor': jitter_factor,
        }
        
        try:
            result = model._session.web_api.ProductionDataUpdate.post_productiondataupdate(post_payload)
            ret_value = production_data_update_status(result.Succeeded, result.StudyName)
            ret_value.succeeded = False
            
            for msg in result.Messages:
                ret_value.add_message(msg.Message, msg.MessageType)
            for prop in result.Properties:
                ret_value.add_property(prop.PropertyName, prop.Equipment, prop.Type, prop.DisplayName, prop.Status)
                
            #save the model to a new location. the save method raises error if invalid path
            model.save(save_as)
            model.close()
            ret_value.succeeded = result.Succeeded
            return ret_value
            
        except PipesimServerError as ex:
            raise ValueError("model cannot be updated due to the following error: {}".format( ex.get_error_message()))

    @staticmethod
    def open(filename: str, units: Optional[str]=Units.FIELD, in_memory_results: Optional[bool]=True):
        """
        Open a PIPESIM model

        Opens the PIPESIM model.

        Parameters
        ----------
        filename : str
            The PIPESIM model path and file name.
        units : str
            The engineering units that will be used by POET. This is one
            of the Units enumerations, with the default being
            FIELD units.
        in_memory_results : bool
            If True simulation results will be deleted after run and will not be saved, otherwise they will be kept and saved.

        Returns
        -------
        Model
            The model object that has been open.

        Examples
        --------
        >>> model = Model.open("C:/POET Demo/CSN_301_small network.pips")
        >>> model = Model.open("C:/MyProject/FlowNetwork.pips", Units.METRIC)

        """

        # No filename provided - stop now
        if not filename:
            raise ValueError('file name is required')

        # Filename is not valid - stop now
        if not os.path.exists(filename):
            raise ValueError('file name {} does not exist'.format(filename))

        # Create the PIPESIM model session from the low level API
        session = create_pipesim_session(filename, unit_system_id=units, in_memory_results = in_memory_results)
        if not session:
            raise ValueError('Cannot make connection to the model')

        try:
            # And lastly pass in the session to ourselves and return the model object
            model = Model(session, filename, units)
            model._in_memory_results = in_memory_results
        except Exception as e:
            # In some cases, there are both exceptions and errors in session manager,
            # in this case, the session manager holds more precise error information,
            # we raise a new exception with the informative error message instead,
            # Examples: license failure
            if session.session_manager is not None:
                session.session_manager.raise_if_errored()

            # if no manager error, we will still throw the underlying exception as is
            raise e
        
        return model

    @staticmethod
    def new(filename : str, units: Optional[str]=Units.FIELD, overwrite: Optional[bool]=False, in_memory_results: Optional[bool]=True):
        """
        Open a new PIPESIM model

        Opens a new PIPESIM model.

        Parameters
        ----------
        filename : str
            The new PIPESIM model path and file name.
        units : str
            The engineering units that will be used by POET. This is one
            of the Units enumerations, with the default being
            FIELD units.
        overwrite : bool
            If the file already exists, this flag will define if
            it should be overwrited or not.
        in_memory_results : bool
            If True simulation results will be deleted after run and will not be saved, otherwise they will be kept and saved.

        Returns
        -------
        Model
            The model object that has been open.

        Examples
        --------
        >>> model = Model.new("C:/POET Demo/new_workspace.pips")
        >>> model = Model.new("C:/MyProject/NewWorkspace.pips", Units.METRIC)

        """
        if os.path.exists(filename) and not overwrite:
            raise ValueError('The file "{}" already exist.'.format(filename))

        full_path = os.path.abspath(NEW_WORKSPACE_PATH)
        model = Model.open(full_path, units, in_memory_results = in_memory_results)
        model.save(filename)
        return model

    def open_ui(self, filename:Optional[str]=""):
        """
        Open a PIPESIM file with PIPESIM UI

        Opens the PIPESIM model file in the PIPESIM UI. It supports opening a
        model directly, and opening the model that is open in the Toolkit. A
        model that is open in the PIPESIM Python Toolkit will be saved and
        closed before opening in the UI. This is because changes cannot be made
        to a model simultaneously in the UI and through the Python Toolkit.

        Parameters
        ----------
        filename : str
            The PIPESIM file path and name. This is not required when opening
            a model that is already open in the Python Toolkit.

        Examples
        --------
        >>> # Without first opening the model in Python
        >>> Model.open_ui("C:/POET Demo/CSN_301_small network.pips")
        >>> # While the model is open in the Python Toolkit
        >>> model = Model.open("C:/POET Demo/CSN_301_small network.pips")
        >>> model.open_ui()

        """

        # Filename is passed through as a static method
        if (type(self) is str):
            filename = self

        # Filename has been passed through while the model is open
        elif filename:
            pass

        # Asking to open the current model
        else:
            filename = self._model_file
            self.save()
            self.close()

        # Verify that the filename path definitely exists
        if not os.path.exists(filename):
            raise ValueError('PIPESIM model file {} does not exist. Check path and spelling'.format(filename))

        # Standardize the path and open
        full_path = os.path.abspath(filename)
        open_ui(full_path)


    def save(self, filename="", view_type=""):
        """
        Save the PIPESIM model

        Saves the PIPESIM model. If the filename is not specified then it
        peforms a save; if the filename is specified then it performs a
        Save As. the suffix "pips" may be omitted.

        Parameters
        ----------
        filename : str
            Optional. The full path and name of the file to save.

        view_type: str
            Optional. The view type(Pipesim UI will open in Network view or well view). 
            can be ViewTypes.WELL or ViewTypes.NETWORK

        Examples
        --------
        >>> model.save()
        >>> model.save("C:/Temp/MyModel2.pips")
        >>> model.save("C:/Temp/MyModel2.pips",ViewTypes.WELL)
        >>> model.save("C:/Temp/MyModel2.pips",ViewTypes.NETWORK)

        """

        # Create the full path, using the specified filename if requested
        if not filename:
            full_path = os.path.abspath(self._model_file)
        else:
            full_path = os.path.abspath(filename)
            # Check if the directory exists
            dir = os.path.dirname(full_path)
            if not os.path.exists(dir):
                raise ValueError('The save as folder {} does not exist. Check path and spelling'.format(dir))

        # Setup the save request in the low level API
        from six.moves.urllib.request import pathname2url
        SaveRequest = self.api.SaveRequest

        if not view_type:
            save_payload = SaveRequest(Url="file:{}".format(pathname2url(full_path)))
        else:
            save_payload = SaveRequest(Url="file:{}".format(pathname2url(full_path)), ViewType=view_type)

        try:
            self.api.Save.post_save(save_payload)
        except PipesimServerError as ex:
            raise RuntimeError("Cannot save model due to the following error: {}".format(ex.get_error_message()))
        self._model_file = full_path


    def close(self):
        """
        Close the PIPESIM model

        Closes the PIPESIM model.

        Parameters
        ----------

        Returns
        -------

        Examples
        --------
        >>> model.close()

        """

        # Close the model and empty the session
        if self._session is not None:
            self._is_open = False
            self._session.shutdown()
            self._model_file = None
            self._session = None
            self._metadata = None
            self._almanac = None
            self._catalog.close()
            self._catalog = None
            self._unit_system = None
            self._tasks = None


    def validate(self)-> List[ValidationIssue]:
        """
        Validates the model or a specified well, task.
        
        Returns
        -------
        list
            a list of ValidationIssue instances.

        Examples
        --------
        >>> issues = model.validate()
        >>> for issue in issues:
                print(issue.message)
                print(issue.path)
                print(issue.property_name)

        """
        return self.__validate()

    @property
    def context(self) -> AbstractModelContext:
        """ The root context of this model.

        Returns
        -------
        AbstractModelContext
            Returns the model context object that matches the entirety of the model.
        """
        return self._catalog.root_context()

    def find(self,
             context: Optional[str] = None,
             component: Optional[str] = None,
             model_context: Optional[AbstractModelContext] = None,
             **context_keywords: str) -> List[str]:
        """ Find the model components in the context.

        Find the specified components in the model.

        Parameters
        ----------
        context: str
            Optional. The context (identifier) of the item to look for.
        component: str
            Optional. The model component to look for.
        model_context: AbstractModelContext
            Optional. The model context object to look for.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        list
            Returns a list of the component contexts (identifiers) of the
            model components that match the specified criteria.

        Examples
        --------
        >>> model.find(component=ModelComponents.CHOKE, Name="CK-1")
        >>> model.find(Well="Well03")
        """
        try:
            merged_context = getset.compute_context(root_context=self.context,
                                                    context=context,
                                                    component=component,
                                                    model_context=model_context,
                                                    context_keywords=context_keywords)
        except ContextError as error:
            _logger.error(str(error))
            return []

        found_contexts = find_contexts(catalog=self._catalog, context=merged_context, component=component)

        return_value = list({str(ctx) for ctx in found_contexts})
        return_value.sort()
        return return_value


    def find_components(self,
                        context: Optional[str] = None,
                        component: Optional[str] = None,
                        model_context: Optional[AbstractModelContext] = None,
                        **context_keywords: str) -> List[AbstractModelContext]:
        """ Find the full context of the specified component

        Returns the context objects of the items found. This is functionally
        similar to the find() but returns the list of AbstractModelContext
        objects rather than the context strings.

        Parameters
        ----------
        context: str
            Optional. The context string to search in.
        component: str
            Optional. The model component to look for.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        list[AbstractModelContext]
            Returns a list of the contexts for each of the model components that match the specified criteria.

        Examples
        --------
        >>> model.find_components(component=ModelComponents.CHOKE, context="CK-1")
        >>> model.find_components(component=ModelComponents.COMPLETION, Well="Well03")
        """
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=component,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        return find_contexts(catalog=self._catalog, context=merged_context, component=component)
    
    def find_component_objects(self,
             context: Optional[str] = None,
             component: Optional[str] = None,
             model_context: Optional[AbstractModelContext] = None,
             **context_keywords: str) -> List[Component]:
        """ Find the model components in the context.

        Find the specified components in the model.

        Parameters
        ----------
        context: str
            Optional. The context (identifier) of the item to look for.
        component: str
            Optional. The model component to look for.
        model_context: AbstractModelContext
            Optional. The model context object to look for.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        list
            Returns a list of the Component instances that match the specified criteria.

        Examples
        --------
        >>> model.find_component_objects(component=ModelComponents.CHOKE, Name="CK-1")
        >>> model.find_component_objects(Well="Well03")
        """
        try:
            merged_context = getset.compute_context(root_context=self.context,
                                                    context=context,
                                                    component=component,
                                                    model_context=model_context,
                                                    context_keywords=context_keywords)
        except ContextError as error:
            _logger.error(str(error))
            return []

        found_contexts = _find_catalog_node_entries(catalog=self._catalog, context=merged_context, component=component)
        return [Component(self, entry) for entry in found_contexts]


    def filter(self,
               context: Optional[str] = None,
               component: Optional[str] = None,
               model_context: Optional[AbstractModelContext] = None,
               **context_keywords: str):
        """
        Filter the model, creating a submodel of the items of interest

        Returns a Model class containing just the items specified in the
        context. It effectively allows filtering of the model on specific
        aspects and then using the usual methods (get/set/etc.) on the filtered
        model.

        Parameters
        ----------
        context: str
            Optional. The context (identifier) of the item to look for.
        component: str
            Optional. The model component to look for.
        model_context: AbstractModelContext
            Optional. The model context object to look for.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        list
            Returns a list of the component contexts (identifiers) of the
            model components that match the specified criteria.

        Examples
        --------
        >>> # Filter for all the flowlines
        >>> filtered_model = model.filter(Flowline=ALL)
        >>> # Filter for all the items in the specified well
        >>> filtered_model = model.filter(Well="Well03")
        """

        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=component,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        return _FilteredModel(self, merged_context)


    def describe(self,
                  context: Optional[str] = None,
                  component: Optional[str] = None,
                  model_context: Optional[AbstractModelContext] = None,
                  parameter: Optional[str] = None,
                  **context_keywords: str):
        """
        Describe a parameter given a context.

        Returns an object with properties for the parameter description
        such as the units of measurement and unit conversions. The available
        properties are:

        - units: The units of measurement, e.g. inches

        - units_symbol: The symbol(s) for the unit of measurement, e.g. ins

        - si_offset: The unit conversion offset (bias) from SI

        - si_factor: The unit conversion factor (gain) from SI


        Parameters
        ----------
        context: str
            Optional. The context (identifier) of the item to look for.
        parameter : str
            Required. The parameter that needs to be described.
        component: str
            Optional. The model component to look for.
        model_context: AbstractModelContext
            Optional. The model context object to look for.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        Description
            The object with the descriptions.

        Examples
        --------
        >>> eu = model.describe(context="Well",
                               parameter=Parameters.Well.TESTRACKTEMPERATURE).units

        """

        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=component,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        return getset._describe(self._almanac,
                                self._catalog,
                                self._session,
                                parameter,
                                merged_context,
                                component)


    # Note that the order of the arguments has been specified so that the
    # user can do get_value("OD","Well:Tubing") without specifying name
    def get_value(self,
                  context: Optional[str] = None,
                  parameter: Optional[str] = None,
                  component: Optional[str] = None,
                  model_context: Optional[AbstractModelContext] = None,
                  **context_keywords: str) -> Any:
        """
        Return a single parameter value from a context in the model.

        The function queries the model for the specified item and parameter
        returning the parameter value. An error is raised if the context
        matches more than one item.

        Parameters
        ----------
        context: str
            Optional. The context (identifier) to search for. 
            Context can also be an instanse of "Component" class.
        parameter : str
            Optional. The parameter on the item to return the value of.
        component : str
            Optional. The type of the item.
        model_context: AbstractModelContext
            The model context object to search for.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        var
            The value of the specified parameter.

        Examples
        --------
        >>> val = model.get_value(context="Choke23",
                                  parameter=Parameters.Choke.BEANSIZE)
        >>> val = model.get_value(Well="Well 23", Choke="CK1",
                                  parameter=Parameters.Choke.BEANSIZE)
        """
        if isinstance(context, Component):
            return self._get_value_internal(parameter, context)

        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=component,
                                                model_context=model_context,
                                                context_keywords=context_keywords)
        return self._get_value_internal(parameter, merged_context, component)

    def set_node_value(self, node, parameter: str, value: Any = None):
        catalog_node_entry = self._catalog.lookup_entry_by_node(node)
        if(catalog_node_entry is None):
            raise ParameterError('node %r does not exist' % (node.id))
        catalog_node_entry.set_node_attribute(parameter, value)

    # Note that the order of the arguments has been specified so that the
    # user can do set_value(23, "OD","Well:Tubing") without specifying name
    def set_value(self,
                  context: Optional[str] = None,
                  parameter: Optional[str] = None,
                  value: Any = None,
                  component: Optional[str] = None,
                  model_context: Optional[AbstractModelContext] = None,
                  **context_keywords: str):
        """
        Set a parameter value on a single context item in the model.

        The function queries the model for the specified item and then sets the
        parameter to the specified value. An error is raised if the context
        matches more than one item.

        Parameters
        ----------
        context: str
            Optional. The context string to search in.
            Context can also be an instanse of "Component" class
        parameter : str
            Required. The parameter on the item to be set.
        value : var
            Required. The value to set the parameter to.
        component : str
            Optional. The type of the item.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Examples
        --------
        >>> model.set_value(context="Choke23",
                            parameter=Parameters.Choke.BEANSIZE, value=4.5)
        >>> model.set_value(Well="Well 23", Choke="CK1",
                            parameter=Parameters.Choke.BEANSIZE, value=5)

        """
        
        if isinstance(context, Component):
            self._set_value_internal(parameter, value, context, component)
        else:
            merged_context = getset.compute_context(root_context=self.context,
                                                    context=context,
                                                    component=component,
                                                    model_context=model_context,
                                                    context_keywords=context_keywords)
            self._set_value_internal(parameter, value, merged_context, component)

    def set_all_value(self,
                      context: Optional[str] = None,
                      parameter: Optional[str] = None,
                      value: Any = None,
                      component: Optional[str] = None,
                      model_context: Optional[AbstractModelContext] = None,
                      **context_keywords: str):
        """
        Set a parameter value for all items in the context.

        The function queries the model for the specified items and then sets
        the parameter to the specified value. It sets the parameter for all
        items within the context.

        Parameters
        ----------
        context: str
            Optional. The context string to search in.
        parameter : str
            Required. The parameter on the item(s) to set.
        value : var
            Required. The value to set the parameter to.
        component : str
            Optional. The type of the item.
        model_context: AbstractModelContext
            The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Examples
        --------
        >>> model.set_all_value(Source=ALL,
                                parameter=Parameters.Source.ASSOCIATEDBLACKOILFLUID,
                                value = 'BK111')

        """
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=component,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        getset.set_all_value(self._almanac, self._catalog, self._session, parameter, value, merged_context, self)

    def get_values(self,
                  context: Optional[str] = None,
                  parameters: List[str] = [],
                  component: Optional[str] = None,
                  model_context: Optional[AbstractModelContext] = None,
                  show_units: bool = False,
                  **context_keywords: str) -> Dict:
        """
        Returns a dictionary with the parameters and values from a context.

        The function queries the model for the specified items and parameters
        returning a dictionary. The key of the dictionary is context string,
        and the value of the dictionary is a sub dictionary, which contains
        parameter as the key and its value

        Parameters
        ----------
        context: str
            Optional. The context string to search in.
        parameters : list
            Optional. The parameter on the item to return the value of. If
            empty or not provided then it returns all the parameters.
        component : str
            Optional. The type of the item.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        Dict
            The dictionary containing the parameter values.

        Examples
        --------
        >>> dict = model.get_values(context="Choke23",
                                    parameters=[Parameters.Choke.BEANSIZE,
                                    Parameters.Choke.CRITICALPRESSURERATIO])
        >>> dict = model.get_values(Well="Well 23", Choke="CK1",
                                    parameters=[Parameters.Choke.BEANSIZE,
                                    Parameters.Choke.CRITICALPRESSURERATIO])

        """
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=component,
                                                model_context=model_context,
                                                context_keywords=context_keywords)


        if not parameters:
            ret_dict = getset.get_all_values(self._almanac, self._catalog, self._session, show_units, merged_context, None)
            # for a fluid, also get the properties of it's Pipe as users don't distinguish between the two.
            # this logic is only needed when no parameter is specified(otherwise the individual parameters(including parameters belonging to Pipe) will be populated anyway
            if ModelComponents.FLOWLINE in context_keywords:
                for fluid_name, prop_dict in ret_dict.items():
                    self.__add_pipe_to_flowline__(fluid_name, prop_dict)
        else:
            ret_dict = getset.get_values(self._almanac, self._catalog, self._session, parameters, show_units, merged_context)

        if merged_context:
            if self.__is_esp_context(merged_context):
                self.__add_esp_motor_and_cable_values(merged_context, ret_dict, show_units, parameters)
                
            fcv_get_set = FcvGetSetValues(self,merged_context)
            if fcv_get_set.is_fcv_context:
                fcv_get_set.add_fcv_catalog_values(ret_dict, show_units, parameters)
        return ret_dict


    def set_values(self, dict: Dict,
                  context: Optional[str] = None,
                  component: Optional[str] = None,
                  model_context: Optional[AbstractModelContext] = None,
                  **context_keywords: str):
        """
        Set parameters values as specified by the Python dictionary.

        The key of the dictionary is context string, and the value of
        the dictionary is a sub dictionary, which specify the
        parameter as key and its value. The dictionary is therefore
        the same format as the get_values() function.

        Parameters
        ----------
        dict : Dict
            Required. The Python dictionary to set the item parameters.

        Examples
        --------
        >>> model.set_values(dict=values)

        """
        need_to_check_for_esp = False
        if context is None and component is None and model_context is None and not(context_keywords):
            merged_context = None
            need_to_check_for_esp = True
        else:
            merged_context = getset.compute_context(root_context=self.context,
                                                    context=context,
                                                    component=component,
                                                    model_context=model_context,
                                                    context_keywords=context_keywords)
            need_to_check_for_esp = self.__is_esp_context(merged_context)
        
        #special handling for esp motor efficiency values
        if need_to_check_for_esp:
            self._check_for_esp_motor_efficiency(dict, model_context=merged_context)

        getset.set_values(self._almanac, self._catalog, self._session, dict, self, merged_context)

    def _check_for_esp_motor_efficiency(self,
            dict: Dict,
            model_context: Optional[AbstractModelContext] = None):

        if model_context:
            # Now we are expecting that dict is parameters dict
            self._set_esp_motor_efficiency_parameters(dict, model_context=model_context)
            return

        for k, parameters in dict.items():
            self._set_esp_motor_efficiency_parameters(parameters, context=k)

    def _set_esp_motor_efficiency_parameters(self, 
            parameters, 
            context: Optional[str] = None,
            model_context: Optional[AbstractModelContext] = None):

        if not isinstance(parameters, Dict):
            return

        for parameter, value in parameters.items():
            if self._is_esp_motor_coefficient_parameter(parameter):
                if model_context is None:
                    model_context = getset.compute_context(root_context=self.context, context=context)

                self._set_esp_motor_coefficients(model_context, parameters)
                break
            
    
    def get_trajectory(self,
                       context: Optional[str] = None,
                       model_context: Optional[AbstractModelContext] = None,
                       **context_keywords: str) -> DataFrame:
        """
        Get the specified well trajectory.

        Get the well trajectory as identified by the specified context. If more
        than one item is found by the context then it will fail.

        Parameters
        ----------
        context: str
            Optional. The context string to search for well.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        pandas.DataFrame
            The trajectory data frame includes following columns: MeasuredDepth
            Inclination, Azimuth and MaxDogLegSeverity

        Examples
        --------
        >>> df = model.get_trajectory(context="Well-1")
        >>> dfw = model.get_trajectory(Well="Well 23")

        """
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        return getset.get_table(self._get_value_internal, Parameters.Well.TRAJECTORY, merged_context)

    def set_trajectory(self,
                       context: Optional[str] = None,
                       value: DataFrame = None,
                       model_context: Optional[AbstractModelContext] = None,
                       **context_keywords: str):
        """
        Set well trajectory to the values specified in the DataFrame.

        Sets well trajectory to the values specified in the DataFrame. It will
        fail if more than one item is found by the context.

        Parameters
        ----------
        value : DataFrame
            Required. The data frame to set to the well trajectory.
        context: str
            Optional. The context string to look for the well.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Examples
        --------
        >>> model.set_trajectory(context="Well-1", value = df)
        >>> model.set_trajectory(Well="Well 23", value = df)

        """
        well_trajectory = WellTrajectory()
        well_trajectory.set_data_frame(value)

        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        self._set_value_internal(Parameters.Well.TRAJECTORY, well_trajectory, merged_context)
        
    def get_completion_ipr_points(self,
             context: Optional[str] = None,
             model_context: Optional[AbstractModelContext] = None,
             **context_keywords: str) -> IprPoints:
        """
        Get pwf and rate values for the ipr model. It will
        fail if more than one item is found by the context.

        Parameters
        ----------
        context: str
            Optional. The context string to search for completion.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        A class with two properties: 
            ipr_points: a pandas.DataFrame containing the pressure and rate values
            messages: a list of stings of any messages produced by ipr calculation
        

        Examples
        --------
        >>> results = model. get_completion_ipr_points(context="Well-1:VertComp")
        >>> print( results.ipr_points)
        >>> for msg in results.messages:
                print(msg)
        """
        try:
            merged_context = getset.compute_context(root_context=self.context,
                                                    context=context,
                                                    model_context=model_context,
                                                    context_keywords=context_keywords)
        except ContextError as error:
            _logger.error(str(error))
            return None

        return get_ipr_points_for_completion(self, merged_context)

    def get_completion_test_points(self,
                                   context: Optional[str] = None,
                                   model_context: Optional[AbstractModelContext] = None,
                                   **context_keywords):
        """
        Return well completion test points found in the context.

        Return well completion test points found in the context. It will fail
        if more than one item is found by the context.

        Parameters
        ----------
        context : str
            Optional. The context string of completion
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).
            e.g. Well ='well_name', Completion = 'completion_name'

        Returns
        -------
        pandas.DataFrame
            The completion test points data frame includes following columns:
            LiquidFlowrate, GasFlowrate, StaticReservoirPressure, BottomHoleFlowingPressure

        Examples
        --------
        >>> df = model.get_completion_test_points(context="Well-1:VertComp")

        """

        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        return getset.get_table(self._get_value_internal, Parameters.Completion.TESTPOINTS, merged_context)
    
    def set_risk_limit(self, dvalue):
        models = self._catalog.lookup_entries_by_class_ids([ModelClasses.MODEL])
        if not models:
            #logger.warning( "Web API model is not retrieved properly.")
            return

        model = self._catalog.get_node_by_id(models[0].node_id)
        if model is None:
            print('Model is None')

    def set_completion_test_points(self,
                                   context: Optional[str] = None,
                                   value: DataFrame = None,
                                   model_context: Optional[AbstractModelContext] = None,
                                   **context_keywords):
        """
        Set data frame to the completion test points of well in the context.

        Set data frame to the completion test points of well in the context. It
        will fail if more than one item is found by the context.

        Parameters
        ----------
        value : DataFrame
            Required. The data frame to set to the well completion test points
        context : str
            Optional. The context string to look for the completion
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Examples
        --------
        >>> model.set_completion_test_points(context="Well-1:VertComp", value = df)

        """
        completion_test_points = CompletionTestPointTable()
        completion_test_points.set_data_frame(value)

        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        self._set_value_internal(Parameters.Completion.TESTPOINTS, completion_test_points, merged_context)
        #test points have changed, we need to invalidate the IPR model as the PI value has been recalculated
        completions = self._catalog.lookup_entries_by_class_ids(ModelClasses.COMPLETION)
        for c in completions:
            if c.context.matches(merged_context):
                completion_node = c.get_node()
                if completion_node.CompModel is None:
                    raise ValueError("No IPRModel is set for the completion.")
                ipr_model = completion_node.CompModel
                self.session.refresh(ipr_model)

    def get_pq_curve(self,
                     context: Optional[str] = None,
                     model_context: Optional[AbstractModelContext] = None,
                     **context_keywords) -> DataFrame:
        """
        Return PQ curve in the context.

        Returns PQ curve in the context. It will fail if more than one item is
        found in the context.

        Parameters
        ----------
        context: str
            Optional. The context string to look for source.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        pandas.DataFrame
            The PQ curve data frame includes the following columns:
            GasFlowRate, LiquidFlowRate, MassFlowRate, Pressure

        Examples
        --------
        >>> df = model.get_pq_curve(context="Source_1")
        >>> dfw = model.get_pq_curve(Source="Source 23")
        """
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.SOURCE,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        return getset.get_table(self._get_value_internal, Parameters.Source.PQCURVE, merged_context)

    def set_pq_curve(self,
                     context: Optional[str] = None,
                     value: DataFrame = None,
                     model_context: Optional[AbstractModelContext] = None,
                     **context_keywords):
        """
        Set data frame to the PQ curve of source in the context.

        Set data frame to the PQ curve of source in the context. It will fail
        if more than one item is found in the context or the source does not
        use PQ curve.

        Parameters
        ----------
        value : DataFrame
            Required. The data frame to set to the source PQ curve
        context: str
            Optional. The context string to look for the source.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Examples
        --------
        >>> model.set_pq_curve(context="Source-1", value = df)
        >>> model.set_pq_curve(Source="Source 23" value = df)

        """
        if value is None:
            raise ValueError("No PQ curve DataFrame provided.")
        pq_curve = PQCurve()
        pq_curve.set_data_frame(value)
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.SOURCE,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        self._set_value_internal(Parameters.Source.PQCURVE, pq_curve, merged_context)
        
    ###################################################################################################################################

    def get_coating(self,
                     context: Optional[str] = None,
                     model_context: Optional[AbstractModelContext] = None,
                     **context_keywords: str) -> DataFrame:
        """
        Return pipe coating table in the context.

        Returns flowline pipe coating table in the context. It will fail if more
        than one item is found in the context.

        Parameters
        ----------
        context: str
            Optional. The context string to search for flowline.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        pandas.DataFrame

        Examples
        --------
        >>> df = model.get_coating(context="FL-3")
        >>> dfw = model.get_coating(Flowline="FL-3")

        """
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.FLOWLINE,
                                                model_context=model_context,
                                                context_keywords=context_keywords)
        entries = self._catalog.lookup_entries_by_context_and_class_ids(merged_context, [self.api.Flowline.cls_type_id])
        if not entries:
            raise ContextError("No nodes of class %r in context %r" % (self.api.Flowline.cls_type_id, merged_context))
        if len(entries) > 1:
            raise ContextError("multiple nodes of class %r in context %r" % (self.api.Flowline.cls_type_id, merged_context))
        
        entry = entries[0]
        coating_profile = PipeCoatingProfile(self)
        return coating_profile.read_from_model(self.session, entry.node_id)
        
    
    def delete_coating(self,
                     context: Optional[str] = None,
                     model_context: Optional[AbstractModelContext] = None,
                     **context_keywords: str):
        """
        Delete pipe coating table in the context. It will fail if more
        than one item is found in the context.
        'U value input' will be reset to 'Specify' if 'Calculate' selected

        Parameters
        ----------
        context: str
            Optional. The context string to search for blackoil.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).


        Examples
        --------
        >>> model.delete_coating(context="FL-3")
        >>> model.delete_coating(Flowline="FL-3")
        """
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.FLOWLINE,
                                                model_context=model_context,
                                                context_keywords=context_keywords)
        entries = self._catalog.lookup_entries_by_context_and_class_ids(merged_context, [self.api.Flowline.cls_type_id])
        if not entries:
            raise ContextError("No nodes of class %r in context %r" % (self.api.Flowline.cls_type_id, merged_context))
        if len(entries) > 1:
            raise ContextError("multiple nodes of class %r in context %r" % (self.api.Flowline.cls_type_id, merged_context))
        
        entry = entries[0]
        coating_profile = PipeCoatingProfile(self)
        coating_profile._delete_coating_points(self.session, entry.node_id)
        

    def set_coating(self,
                     context: Optional[str] = None,
                     value: DataFrame = None,
                     model_context: Optional[AbstractModelContext] = None,
                     **context_keywords):
        """
        Set data frame to the pipe coating table in the context.

        Set data frame to the  pipe coating table in the context. It will
        fail if more than one item is found in the context.

        Parameters
        ----------
        value : DataFrame
            Required. The data frame to set to flowline model
        context: str
            Optional. The context string to search for flowline.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Examples
        --------
        >>> model.set_coating(context="FL-3", value = df)
        >>> model.set_coating(Flowline="FL-3", value = df)

        """

        
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.FLOWLINE,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        entries = self._catalog.lookup_entries_by_context_and_class_ids(merged_context, [self.api.Flowline.cls_type_id])
        if not entries:
            raise ContextError("No nodes of class %r in context %r" % (self.api.Flowline.cls_type_id, merged_context))
        if len(entries) > 1:
            raise ContextError("multiple nodes of class %r in context %r" % (self.api.Flowline.cls_type_id, merged_context))
        
        entry = entries[0]
        coating_profile = PipeCoatingProfile(self)
        coating_profile.save_to_model(self.session, entry.node_id, value)
###################################################################################################################################
    
    def raise_exception_if_completion_ipr_model_is_not_Darcy(self, model_context: Optional[AbstractModelContext] = None):
        ipr_model = self.get_value(model_context=model_context, parameter=Parameters.Completion.IPRMODEL)
        if ipr_model != Constants.IPRModels.IPRDARCY:
            raise ContextError("Relative permeability is not available for IPR model: %r." % (ipr_model))  

    def get_relative_permeability_data(self,
                     context: Optional[str] = None,
                     model_context: Optional[AbstractModelContext] = None,
                     **context_keywords: str) -> DataFrame:
        """
        Return relative permeability data in the context.

        Returns Darcy IPR model relative permeability data in the context. It will fail if more
        than one item is found in the context.

        Parameters
        ----------
        context: str
            Optional. The context string to search for Darcy IPR model.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        pandas.DataFrame

        Examples
        --------
        >>> df = model.get_relative_permeability_data(context="Well:Comp-1:IPRDARCY")
        >>> dfw = model.get_relative_permeability_data(Well="Well", Completion="Comp-1")

        """
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.IPRDARCY,
                                                model_context=model_context,
                                                context_keywords=context_keywords)
        entries = self._catalog.lookup_entries_by_context_and_class_ids(merged_context, [self.api.DarcyCompletionModel.cls_type_id])
        if not entries:
            raise ContextError("No nodes of class %r in context %r" % (self.api.DarcyCompletionModel.cls_type_id, merged_context))
        if len(entries) > 1:
            raise ContextError("multiple nodes of class %r in context %r" % (self.api.DarcyCompletionModel.cls_type_id, merged_context))
        self.raise_exception_if_completion_ipr_model_is_not_Darcy(model_context)

        entry = entries[0]
        relative_permeability_data = RelativePermeabilityData(self)
        return relative_permeability_data.read_from_model(self.session, entry.node_id)
       
    def delete_relative_permeability_data(self,
                     context: Optional[str] = None,
                     model_context: Optional[AbstractModelContext] = None,
                     **context_keywords: str):
        """
        Delete relative permeability data in the context. It will fail if more
        than one item is found in the context. The UseRelativePermeability flag on 
        the Darcy IPR model will be set to False.

        Parameters
        ----------
        context: str
            Optional. The context string to search for Darcy IPR model.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).


        Examples
        --------
        >>> model.delete_relative_permeability_data(context="Well:Comp-1:IPRDARCY")
        >>> model.delete_relative_permeability_data(Well="Well", Completion="Comp-1")
        """
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.IPRDARCY,
                                                model_context=model_context,
                                                context_keywords=context_keywords)
        entries = self._catalog.lookup_entries_by_context_and_class_ids(merged_context, [self.api.DarcyCompletionModel.cls_type_id])
        if not entries:
            raise ContextError("No nodes of class %r in context %r" % (self.api.DarcyCompletionModel.cls_type_id, merged_context))
        if len(entries) > 1:
            raise ContextError("multiple nodes of class %r in context %r" % (self.api.DarcyCompletionModel.cls_type_id, merged_context))
        self.raise_exception_if_completion_ipr_model_is_not_Darcy(model_context)

        entry = entries[0]
        relative_permeability_data = RelativePermeabilityData(self)
        return relative_permeability_data._delete_relative_permeability_points(self.session, entry.node_id)
        

    def set_relative_permeability_data(self,
                     context: Optional[str] = None,
                     value: DataFrame = None,
                     model_context: Optional[AbstractModelContext] = None,
                     **context_keywords):
        """
        Set data frame to the relative permeability data in the context.
        It will fail if more than one item is found in the context.
        The UseRelativePermeability flag on the Darcy IPR model will be set to True.

        Parameters
        ----------
        value : DataFrame
            Required. The data frame to set to Darcy IPR model
        context: str
            Optional. The context string to search for Darcy IPR model.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Examples
        --------
        >>> model.set_relative_permeability_data(context="Well:Comp-1:IPRDARCY", value = df)
        >>> model.set_relative_permeability_data(Well="Well", Completion="Comp-1", value = df)

        """

        
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.IPRDARCY,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        entries = self._catalog.lookup_entries_by_context_and_class_ids(merged_context, [self.api.DarcyCompletionModel.cls_type_id])
        if not entries:
            raise ContextError("No nodes of class %r in context %r" % (self.api.DarcyCompletionModel.cls_type_id, merged_context))
        if len(entries) > 1:
            raise ContextError("multiple nodes of class %r in context %r" % (self.api.DarcyCompletionModel.cls_type_id, merged_context))
        self.raise_exception_if_completion_ipr_model_is_not_Darcy(model_context)

        entry = entries[0]
        relative_permeability_data = RelativePermeabilityData(self)
        return relative_permeability_data.save_to_model(self.session, entry.node_id, value)

###################################################################################################################################
        
    def get_deadoil_viscosity_table(self,
                     context: Optional[str] = None,
                     model_context: Optional[AbstractModelContext] = None,
                     **context_keywords: str) -> DataFrame:
        """
        Return blackoil user viscosity table in the context.

        Returns blackoil user viscosity table in the context. It will fail if more
        than one item is found in the context.

        Parameters
        ----------
        context: str
            Optional. The context string to search for blackoil.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        pandas.DataFrame

        Examples
        --------
        >>> df = model.get_deadoil_viscosity_table(context="Heavy_Oil")
        >>> dfw = model.get_deadoil_viscosity_table(BlackOilFluid="Heavy_Oil")

        """
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.BLACKOILFLUID,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        return getset.get_table(self._get_value_internal, Parameters.BlackOilFluid.USERVISCOSITYTABLE, merged_context)
    
    def delete_deadoil_viscosity_table(self,
                     context: Optional[str] = None,
                     model_context: Optional[AbstractModelContext] = None,
                     **context_keywords: str):
        """
        Delete blackoil user viscosity table in the context. It will fail if more
        than one item is found in the context.
        Dead oil correlation will be reset to Beggs & Robinson if user table is selected

        Parameters
        ----------
        context: str
            Optional. The context string to search for blackoil.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).


        Examples
        --------
        >>> model.deletet_deadoil_viscosity_table(context="Heavy_Oil")
        >>> model.delete_deadoil_viscosity_table(BlackOilFluid="Heavy_Oil")
        """
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.BLACKOILFLUID,
                                                model_context=model_context,
                                                context_keywords=context_keywords)
        entries = self._catalog.lookup_entries_by_context_and_class_ids(merged_context, [self.api.BlackOilFluid.cls_type_id])
        if not entries:
            raise ContextError("No nodes of class %r in context %r" % (self.api.BlackOilFluid.cls_type_id, merged_context))
        if len(entries) > 1:
            raise ContextError("multiple nodes of class %r in context %r" % (self.api.BlackOilFluid.cls_type_id, merged_context))
        
        entry = entries[0]
        viscosity_profile = BlackOilViscosityProfile()
        viscosity_profile._delete_viscosity_points(self.session, entry.node_id)
        

    def set_deadoil_viscosity_table(self,
                     context: Optional[str] = None,
                     value: DataFrame = None,
                     model_context: Optional[AbstractModelContext] = None,
                     **context_keywords):
        """
        Set data frame to the  blackoil user viscosity table in the context.

        Set data frame to the  blackoil user viscosity table in the context. It will
        fail if more than one item is found in the context.

        Parameters
        ----------
        value : DataFrame
            Required. The data frame to set to black oil model
        context: str
            Optional. The context string to search for blackoil.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Examples
        --------
        >>> model.set_deadoil_viscosity_table(context="Heavy_Oil", value = df)
        >>> model.set_deadoil_viscosity_table(BlackOilFluid="Heavy_Oil", value = df)

        """

        viscosity_profile = BlackOilViscosityProfile()
        viscosity_profile.set_data_frame(value)
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.BLACKOILFLUID,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        self._set_value_internal(Parameters.BlackOilFluid.USERVISCOSITYTABLE, viscosity_profile, merged_context, ModelComponents.BLACKOILFLUID)
###################################################################################################################################

    def get_mix_viscosity_table(self,
                     context: Optional[str] = None,
                     model_context: Optional[AbstractModelContext] = None,
                     **context_keywords: str) -> DataFrame:
        """
        Return blackoil user mixture viscosity table in the context.

        Returns blackoil user mixture viscosity table in the context. It will fail if more
        than one item is found in the context.

        Parameters
        ----------
        context: str
            Optional. The context string to search for blackoil.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        pandas.DataFrame

        Examples
        --------
        >>> df = model.get_mix_viscosity_table(context="Heavy_Oil")
        >>> dfw = model.get_mix_viscosity_table(BlackOilFluid="Heavy_Oil")

        """
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.BLACKOILFLUID,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        return getset.get_table(self._get_value_internal, Parameters.BlackOilFluid.USEREMULSIONTABLE, merged_context)
    
    def delete_mix_viscosity_table(self,
                     context: Optional[str] = None,
                     model_context: Optional[AbstractModelContext] = None,
                     **context_keywords: str):
        """
        Delete blackoil user mixture viscosity table in the context. It will fail if more
        than one item is found in the context.
        Emulsion viscosity method will be reset to 'Set to viscosity of the continuous phase' if user table is selected

        Parameters
        ----------
        context: str
            Optional. The context string to search for blackoil.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).


        Examples
        --------
        >>> model.delete_mix_viscosity_table(context="Heavy_Oil")
        >>> model.delete_mix_viscosity_table(BlackOilFluid="Heavy_Oil")
        """
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.BLACKOILFLUID,
                                                model_context=model_context,
                                                context_keywords=context_keywords)
        entries = self._catalog.lookup_entries_by_context_and_class_ids(merged_context, [self.api.BlackOilFluid.cls_type_id])
        if not entries:
            raise ContextError("No nodes of class %r in context %r" % (self.api.BlackOilFluid.cls_type_id, merged_context))
        if len(entries) > 1:
            raise ContextError("multiple nodes of class %r in context %r" % (self.api.BlackOilFluid.cls_type_id, merged_context))
        
        entry = entries[0]
        viscosity_profile = BlackOilEmulsionProfile()
        viscosity_profile._delete_Emulsion_points(self.session, entry.node_id)
        

    def set_mix_viscosity_table(self,
                     context: Optional[str] = None,
                     value: DataFrame = None,
                     model_context: Optional[AbstractModelContext] = None,
                     **context_keywords):
        """
        Set data frame to the  blackoil user mixture viscosity table in the context.

        Set data frame to the  blackoil user mixture viscosity table in the context. It will
        fail if more than one item is found in the context.

        Parameters
        ----------
        value : DataFrame
            Required. The data frame to set to black oil model
        context: str
            Optional. The context string to search for blackoil.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Examples
        --------
        >>> model.set_mix_viscosity_table(context="Heavy_Oil", value = df)
        >>> model.set_mix_viscosity_table(BlackOilFluid="Heavy_Oil", value = df)

        """

        viscosity_profile = BlackOilEmulsionProfile()
        viscosity_profile.set_data_frame(value)
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.BLACKOILFLUID,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        self._set_value_internal(Parameters.BlackOilFluid.USEREMULSIONTABLE, viscosity_profile, merged_context, ModelComponents.BLACKOILFLUID)
###################################################################################################################################

    def get_geometry(self,
                     context: Optional[str] = None,
                     model_context: Optional[AbstractModelContext] = None,
                     **context_keywords: str) -> DataFrame:
        """
        Return flowline geometry profile in the context.

        Returns flowline geometry profile in the context. It will fail if more
        than one item is found in the context.

        Parameters
        ----------
        context: str
            Optional. The context string to search for flowline.
            Context can also be an instanse of "Component" class.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        pandas.DataFrame
            If flowline is in detialed mode, return flowline detailed profile data.

        Examples
        --------
        >>> df = model.get_geometry(context="fl-1")
        >>> dfw = model.get_geometry(Flowline="fl-2")

        """
        if isinstance(context, Component):
            flowlineGeometryProfile = FlowlineGeometryProfile()
            return flowlineGeometryProfile._get_geometry_profile_data_frame(self._session, context._get_node())
        
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.FLOWLINE,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        return getset.get_table(self._get_value_internal, Parameters.Flowline.GEOMETRYPROFILE, merged_context)

    def set_geometry(self,
                     context: Optional[str] = None,
                     value: DataFrame = None,
                     model_context: Optional[AbstractModelContext] = None,
                     **context_keywords):
        """
        Set data frame to the flowline geometry profile in the context.

        Set data frame to the flowline geometry profile in the context. It will
        fail if more than one item is found in the context.

        Parameters
        ----------
        value : DataFrame
            Required. The data frame to set to the flowline geometry profile
        context: str
            Optional. The context string to search for flowline.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Examples
        --------
        >>> model.set_geometry(context="fl-1", value = df)
        >>> model.set_geometry(Flowline="fl-2", value = df)

        """

        flowline_profile = FlowlineGeometryProfile()
        flowline_profile.set_data_frame(value)
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.FLOWLINE,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        self._set_value_internal(Parameters.Flowline.GEOMETRYPROFILE, flowline_profile, merged_context, ModelComponents.FLOWLINE)

    def get_geothermal_profile(self,
                               context: Optional[str] = None,
                               model_context: Optional[AbstractModelContext] = None,
                               **context_keywords: str) -> DataFrame:
        """
        Return the flowline or well geothermal profile in the context.

        Returnz the flowline or well geothermal profile in the context. It will fail
        if more than one item is found in the context.

        Parameters
        ----------
        context: str
            Optional. The context string to search for flowline or well.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        pandas.DataFrame
            Return geothermal data frame.
            If flowline is simple, or geothermal data use global settings, empty data frame is returned.

        Examples
        --------
        >>> df = model.get_geothermal_profile(context="fl-1")
        >>> dfw = model.get_geothermal_profile(Well="well-1")

        """
        merged_context = getset.compute_context(root_context=self.context,
                                        context=context,
                                        model_context=model_context,
                                        context_keywords=context_keywords)

        from sixgill.core.geothermal_profile import get_component_and_parameter
        component, parameter = get_component_and_parameter(self._catalog, merged_context)

        # if it's a well, we need to make sure the context can find the borehole of that
        # well in order to get the geothermal survey
        if component == ModelComponents.WELL and SchemaNodes.NAME in merged_context:
            name = merged_context.pop(SchemaNodes.NAME, None)
            update_well_context(name, merged_context)

        return getset.get_table(self._get_value_internal, parameter, merged_context)

    def set_geothermal_profile(self,
                               context: Optional[str] = None,
                               value: DataFrame = None,
                               model_context: Optional[AbstractModelContext] = None,
                               **context_keywords: str):
        """
        Set the DataFrame values to the flowline geothermal profile in the context.

        Sets the DataFrame values to the flowline geothermal profile in the context. It will
        fail if more than one item is found in the context.

        Parameters
        ----------
        value : DataFrame
            Required. The data frame to set to the flowline geothermal profile
        context: str
            Optional. The context string to search for flowline or well.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Examples
        --------
        >>> model.set_geothermal_profile(context="fl-1", value = df)
        >>> model.set_geothermal_profile(Flowline="fl-2", value = df)

        """
        merged_context = getset.compute_context(root_context=self.context,
                                        context=context,
                                        model_context=model_context,
                                        context_keywords=context_keywords)

        from sixgill.core.geothermal_profile import get_component_and_parameter
        component, parameter = get_component_and_parameter(self._catalog, merged_context)

        if component == ModelComponents.FLOWLINE:
            profile = FlowlineGeothermalProfile()
        elif component == ModelComponents.WELL:
            profile = BoreholeGeothermalSurvey(self)
            if SchemaNodes.NAME in merged_context:
                # we need to make sure the context can find the borehole of that
                # well in order to get the geothermal survey
                name = merged_context.pop(SchemaNodes.NAME, None)
                update_well_context(name, merged_context)

        profile.set_data_frame(value)

        self._set_value_internal(parameter, profile, merged_context)
        
    def __is_esp_context(self, model_context):
        if not model_context:
            return False
        if model_context.get(ModelComponents.ESP):
            return True
        return False     
    
    def _get_value_internal(self,
                            parameter: str,
                            model_context: AbstractModelContext,
                            component: Optional[str] = None) -> Any:
        """Internal implementation of get_value() where the context has been fully built.
        """
        merged_context = model_context
        if isinstance(model_context, Component):
            merged_context = model_context.context
            
        if self.__is_esp_context(merged_context):
            ret_dict = {}
            if self._is_esp_motor_coefficient_parameter(parameter):
                self.__add_esp_motor_coefficients_values([parameter], merged_context, False, ret_dict)
                if ret_dict:
                    key = list(ret_dict.keys())[0]
                    return ret_dict[key] 
                return None
            
            calss_type_id = None
            if parameter.upper() in dir(Parameters.ESP.CableCatalogData):
                calss_type_id = self.api.CableCatalogData.cls_type_id
            if parameter.upper() in dir(Parameters.ESP.MotorCatalogData):
                calss_type_id = self.api.ESPMotorCatalogData.cls_type_id
                
            if calss_type_id:
                # Figure out which classes we care about (and their parameter mappers)
                class_to_mapping_dict = self._almanac.lookup_by_parameter(parameter)
                if not class_to_mapping_dict:
                    raise ParameterError('Parameter %r does not exist' % (parameter))
                entries = self._catalog.lookup_entries_by_context_and_class_ids(merged_context, [calss_type_id])
                if not entries:
                    return None
                return class_to_mapping_dict[entries[0].class_id].get_parameter_value(entries[0], self._session)   
        fcv_get_set = FcvGetSetValues(self,merged_context)
        if fcv_get_set.is_fcv_context:
            success, fcv_value = fcv_get_set.get_value(parameter)
            if success:
                return fcv_value
            
        return getset.get_value(self._almanac,
                                     self._catalog,
                                     self._session,
                                     parameter,
                                     model_context,
                                     component)

    def _set_esp_motor_coefficients(self, context: AbstractModelContext, parameters: dict ):
        
        amp_values = parameters.pop(Parameters.ESP.MotorCoefficients.AMPValues,[])
        pf_values = parameters.pop(Parameters.ESP.MotorCoefficients.PFValues,[])
        ef_values = parameters.pop(Parameters.ESP.MotorCoefficients.EFFValues,[])
        
        if not amp_values and not pf_values and not ef_values:
            #No motor coefficient values specified. Do nothing
            return
        
        if not isinstance(parameters,dict):
            raise ParameterError("parameter for esp coefficients must be a dictionary")
        
        merged_context = context
        if isinstance(context, Component):
            merged_context = context.context
        entries = self._catalog.lookup_entries_by_context_and_class_ids(context, [self.api.ESPMotorCoefficient.cls_type_id])
        if not entries:
            raise ParameterError("Did not find any motor coefficients for the given context".format(context))
        
        coefficient_nodes = [entry.get_node() for entry in entries]
        #sort the coefficients based on the coefficintIndex
        coefficient_map = {}
        for coefficient in coefficient_nodes:
            coefficient_map[coefficient.CoefficientIndex] = coefficient
            
        index = -1
        for amp in amp_values:
            index = index + 1
            motor_coefficient = coefficient_map[index]
            if motor_coefficient is None:
                continue
            motor_coefficient.AMPValue = amp
    
        index = -1
        for pf in pf_values:
            index = index + 1
            motor_coefficient = coefficient_map[index]
            if motor_coefficient is None:
                continue
            motor_coefficient.PFValue = pf
    
        index = -1
        for ef in ef_values:
            index = index + 1
            motor_coefficient = coefficient_map[index]
            if motor_coefficient is None:
                continue
            motor_coefficient.EFFValue = ef
        
    def _is_esp_motor_coefficient_parameter(self, parameter: str):
        return (parameter == Parameters.ESP.MotorCoefficients.AMPValues) or\
               (parameter == Parameters.ESP.MotorCoefficients.PFValues) or\
               (parameter == Parameters.ESP.MotorCoefficients.EFFValues)
    
    def __add_esp_motor_and_cable_values(self, merged_context, ret_dict, show_units, parameters):
        #Get the Motor and cable properties(scalar values)
        entries = self._catalog.lookup_entries_by_context_and_class_ids(merged_context, [self.api.ESPMotorCatalogData.cls_type_id, self.api.CableCatalogData.cls_type_id])
        local_dict = getset.get_all_values(self._almanac, self._catalog, self._session, show_units, merged_context, entries)
        if local_dict:
            for key, values_map in local_dict.items():
                for parameter_name, value in values_map.items():
                    if not parameters or parameter_name in parameters: 
                        ret_dict[key][parameter_name] = value
                        
        #now get the Motor coefficients
        key = list(ret_dict.keys())[0]
        self.__add_esp_motor_coefficients_values(parameters, merged_context, show_units, ret_dict[key])

    def __add_esp_motor_coefficients_values(self, parameters, merged_context, show_units, ret_dict):
        if not parameters or Parameters.ESP.MotorCoefficients.AMPValues in parameters\
            or Parameters.ESP.MotorCoefficients.EFFValues in parameters\
                or Parameters.ESP.MotorCoefficients.PFValues in parameters:
            amp_values = [NAN] * 6
            eff_values = [NAN] * 6
            pf_values = [NAN] * 6
            entries = self._catalog.lookup_entries_by_context_and_class_ids(merged_context, [self.api.ESPMotorCoefficient.cls_type_id])
            for entry in entries:
                node = entry.get_node()
                amp_values[node.CoefficientIndex] = node.AMPValue
                eff_values[node.CoefficientIndex] = node.EFFValue
                pf_values[node.CoefficientIndex] = node.PFValue
                
            if not parameters or Parameters.ESP.MotorCoefficients.AMPValues in parameters:
                ret_dict[Parameters.ESP.MotorCoefficients.AMPValues] = amp_values                 
            if not parameters or Parameters.ESP.MotorCoefficients.EFFValues in parameters:
                ret_dict[Parameters.ESP.MotorCoefficients.EFFValues] = eff_values                 
            if not parameters or Parameters.ESP.MotorCoefficients.PFValues in parameters:
                ret_dict[Parameters.ESP.MotorCoefficients.PFValues] = pf_values
  
    def _refresh_tubing_section_nodes(self, node):
        #find all the tubing sections belonging to the  parent well string and update them
        if node is None:
            return
        tubing_string = node.WellString
        tubing_string_id = tubing_string.id.split("/api/")[-1]
        for entry in self._catalog.lookup_entries_by_parent_id_and_class_id(tubing_string_id, ModelClasses.TUBING):
            self.session.refresh(entry.get_node())
    
    def _set_value_internal(self, parameter: str, value: Any, model_context: AbstractModelContext, component: str = None):
        """Internal implementation of set_value() where the context has been fully built.
        """
        
        if self._is_esp_motor_coefficient_parameter(parameter):
                self._set_esp_motor_coefficients(model_context, {parameter:value})
                return
            
        fcv_get_set = FcvGetSetValues(self,model_context)
        if fcv_get_set.is_fcv_context and fcv_get_set.set_value(parameter, value):
            return
        
        entry = getset.set_value(self._almanac,
                         self._catalog,
                         self._session,
                         parameter,
                         value,
                         model_context,
                         component)

        # Refresh node if required
        
        #if we are setting the TopMeasuredDepth/Length of a tubingSection, then the connected sections may also change. refresh them all
        if parameter == Parameters.Tubing.TOPMEASUREDDEPTH or parameter == Parameters.Tubing.LENGTH:
            node = self._catalog.get_node_by_id(entry.node_id)
            if node is None:
                return
            calss_type =  node.type_id.split("/api/")[-1]
            if calss_type == ModelClasses.TUBING:
                self._refresh_tubing_section_nodes(node)
            return
            
            
        if parameter in NODE_REFRESH_REQUIRED and entry is not None:
            node = self._catalog.get_node_by_id(entry.node_id)
            if node is None:
                return
            self.session.refresh(node)
                      

    def read_catalog(self,
                     context = None,
                     model_context: Optional[AbstractModelContext] = None,
                     **context_keywords: str):
        """
        Update the equipment data from the catalog.

        Update equipment data for an FCV, ESP, PCP, Pump or Compressor from the
        catalog. The equipment must have Manufacturer and Model set so that the
        entry in the catalog can be identified. It will fail if more than one
        item is found in the context.

        Parameters
        ----------
        context : str
            Optional. The context string to look for pump
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Examples
        --------
        >>> model.read_catalog(context="Pump-1")

        """
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                model_context=model_context,
                                                context_keywords=context_keywords)
        from sixgill.core.add import _load_pump_catalog
        _load_pump_catalog(self, merged_context)

    @contextmanager
    def batch_update(self):
        """
        Apply batch updates to the model

        Ordinarily changes to the model through set...() are immediately
        applied. The batch update allows a series of updates to be cached and
        then updated as group. This is useful where many changes need to be
        applied, which can be bundled together and applied all at once. This
        has a performance improvement over individual updates.

        Returns
        -------
        None

        Examples
        --------
        >>> with model.batch_update():
                model.set_value("Choke", Parameters.Choke.BEANSIZE, 56)
                model.set_geometry("FL-1", geometry_df)

        """
        self._session.patch_builder.on_trait_event(self._session._update, 'patches_items', remove=True)

        try:
            yield
        finally:
            try:
                self._session._update()
            finally:
                # Re-register the auto-patching listener
                self._session.patch_builder.on_trait_event(self._session._update, 'patches_items')


    @property
    def about(self):
        """
        Return information about the current PIPESIM version.

        Returns the versions of PIPESIM, web API and PIPESIM Python Toolkit
        that are being used. Called as a function about() it returns a
        dictionary of the version information. It will also return the
        individual properties of the ModelAbout() class.

        Parameters
        ----------
        None

        Returns
        -------
        dict
            Information about the PIPESIM version.

        Examples
        --------
        >>> version_dict = model.about()
        >>> webapi_version = model.about.webapi_version

        """

        # No session set - kick them out now
        if (self._session is None):
            return None

        about = ModelAbout(self)
        return about

    def get_elevation(self, lat: float, long: float) -> float:
        """
        Get the elevation of a location

        Returns the elevation of the latitude / longitude location.

        Parameters
        ----------
        lat : float
            Required. The latitude of the location in degree.

        long : float
            Required. The longitude of the location in degree.

        Returns
        -------
        float
            The elevation of the location with specified lat and long in meter
            Raise ValueError exception if the location is invalid.

        Examples
        --------
        >>> elev = model.get_elevation(0.2, 0.5)

        """

        return _get_elevation(self.api, self._session.units_mgr, lat, long)


    def get_elevations(self, locations):
        """
        Get the elevation of a array of location points with latitude longitude

        Returns an array of location points with latitude, longitude and elevation.

        Parameters
        ----------
        location : array[dic{Longitude:value,Latitude:value}, ...]
            Required. Location array with longitude and latitude points.

        Returns
        -------
        array[dic{Longitude:value,Latitude:value, Elevetion:value}, ...]
            The location array with latitude, longitude and elevetion values for each point.
            Raise ValueError exception if the location is invalid.

        Examples
        --------
        >>> location = model.get_elevations([{Parameters.Location.LATITUDE:0.2,Parameters.Location.LONGITUDE:0.5}])

        """
        return _get_elevations(self.api, self._session.units_mgr, locations)

    def export_parameters(self, filename: str, with_templates: bool = False) -> str:
        """ Export the model parameters to a CSV file.

        Exports the model parameters to a comma separated values (CSV) file.
        Note that this only includes the scalar model parameters and simulation
        settings; tabulated data such as trajectories and profiles are not
        included.

        Parameters
        ----------
        filename : str
            Required. The name of the CSV filename to save the CSV.
        with_templates : bool
            Optional. Whether to include templates (True) or not (False). The
            default is False.

        Returns
        -------
        str
            The full absolute path to the CSV file saved.

        Examples
        --------
        >>> file = model.export_parameters(filename="C:/poet/model_details.pips")

        """
        if not self.is_open:
            raise RuntimeError('The model is closed')

        factlist = ModelFactList.from_session(self._session, self._catalog, \
            self._almanac, with_templates)

        return factlist.to_csv(filename)

    @property
    def sim_settings(self):
        """ The simulation settings """

        # No session set - kick them out now
        if (self._session is None):
            return None

        # Import the module as needed and return the model settings
        from sixgill.model_setting import ModelSetting
        settings = ModelSetting(self)
        return settings

    @property
    def fluids(self):
        """ The fluid settings, primarily setting up compositional fluids """

        # No session set - kick them out now
        if (self._session is None):
            return None

        # Import the module as needed and return the compositional fluid settings
        from sixgill.compositional import FluidSettings
        settings = FluidSettings(self)
        return settings

    @property
    def tasks(self):
        """ The simulation tasks """

        # No session set - kick them out now
        if (self._session is None):
            return None

        if self._tasks:
            return self._tasks

        # Import the module as needed and return the compositional fluid settings
        self._tasks = Task(self)
        return self._tasks

    def export_well(self,
                    context: Optional[str] = None,
                    folder: Optional[str] = None,
                    model_context: Optional[AbstractModelContext] = None,
                    well_names: Optional[List[str]] = None,
                    **context_keywords: str) -> List[str]:
        """
        Export the specified well(s) into PIPESIM files

        Exports the specified well(s) in to individual PIPESIM files in
        the specified folder. The filename will match the well name. If the
        well name is not specified then all the wells in the model are
        exported. If folder is not specified, then the wells are exported to
        the current working folder

        Parameters
        ----------
        context: str
            Optional. The context string to search for well.
        folder : str
            Optional. The folder location to save the files into.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).
        well_names: List[str]
            Optional. A list of well names to be exported. If this parameter is specified, the context,
            model_context and context_keywords are ignored

        Returns
        -------
        list
            The list of filenames with full path of each well exported.

        Examples
        --------
        >>> files = model.export_well()
        >>> files = model.export_well(context="Well 03")
        >>> files = model.export_well(Well="Well 1")

        """

        if well_names:
            return export_wells(self._session, self._catalog, folder, well_names)

        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.WELL,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        return export_well(self._session,self._catalog, folder, merged_context, well_names=well_names)

    def import_well(self, filename, name, fluid_override=False, overwrite_existing=False):
        """
        Import a well into the model.

        Imports the well from the file into the model with the specified
        options.

        Parameters
        ----------
        filename : str
            Required. The filename to import the well from
        name : str
            Required. The name that will be given to the well in the model.
        fluid_override: bool
            Specifies whether the fluid from the well import file overwrites
            the existing fluid in the model (True) or not (False).
        overwrite_existing: bool
            Specifies whether the well will overwrite (replace) an existing
            well in the model with the same name.

        Examples
        --------
        >>> model.import_well(filename="C:/temp/mywells/Well01.pips", name="Well02",
                              fluid_override=False, over_write_existing=False)

        """
        import_well(self._catalog, self._session, filename, name, fluid_override, overwrite_existing)

    def import_wells(self, folder ,fluid_override=False, cache_update=True):
                    
        """
        import all wells from a specified folder

        Parameters
        ----------
        folder: str
            The folder location where the .pips files are located. All the pips files in the folder will be imported
            The file name must match to a well name inside the model.
        fluid_override: bool
            Specifies whether the fluid from the well import file overwrites
            the existing fluid in the model (True) or not (False).
        cache_update: bool
            If False, the cache is not updated(better performance). User should exit the session afterwards as the cache is not reflecting the newly imported wells

        Returns
        -------
        List[str]
            Returns a list of well names of the imported wells

        Examples
        --------
        >>> folder = "C:/ImportFolder"
        >>> imported_well_names = model.import_wells(folder)
        >>> imported_well_names = model.import_wells(folder, True)
        >>> imported_well_names = model.import_wells(folder, True, True)

        """
        return import_wells(self._catalog, self._session, folder, fluid_override, cache_update)

    def delete(self,
               context: Optional[str] = None,
               component: Optional[str] = None,
               model_context: Optional[AbstractModelContext] = None,
               parameter: Optional[str] = None,
               **context_keywords: str):
        """
        Delete components from the model.

        Deletes the specified components from the model

        Parameters
        ----------
        context: str
            Optional. The context string to search in.
        component: str
            Optional. The model component to look for.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Examples
        --------
        >>> model.delete(context="Sep01")

        """
        merged_context = getset.compute_context(root_context=self.context,
                                        context=context,
                                        component=component,
                                        model_context=model_context,
                                        context_keywords=context_keywords)
        _delete(catalog=self._catalog, session=self._session, context=merged_context, component=component)


    def add(self, component, name, context: Optional[str]=None, parameters: Optional[dict]={}):
        """
        Adds components to the model.

        Create a new items in the model of the specified component type.

        Parameters
        ----------
        component : str
            Required. The type of model component to add to the model. This
            is one of the ModelComponents enumerations.
        name : str
            Required. The name of the item added to the model.
        context : str
            Optional. The string representation of the context to add the component.
            For example, when adding downhole object to a well, it is the context string of the well.
        parameters: dict
            Optional. The parameters to set when creating the item. If not
            specified then the item is created with the default parameters.

        Examples
        --------
        >>> model.add(component=ModelComponents.BLACKOILFLUID, name="BO_01",
                      parameters={Parameters.BlackOilFluid.GOR:200})
        >>> model.add(component=ModelComponents.CHOKE, name="TSV-01",
                     {Parameters.Choke.BEANSIZE:5})
        >>> model.add(component=ModelComponents.CHOKE, name="ck", context="Well 1",
                      parameters={Parameters.DowholeLocation.TOPMEASUREDDEPTH:500,
                      Parameters.Choke.BEANSIZE=4.5})

        """
        _add(self, component, name, context, parameters)

    def copy(self, context: str, name:str, use_template:Optional[bool] = False):
        """
        Duplicate an item in the model.

        Copy a model component. **Note that it only works for the following
        components in the current release**:

        - Well

        Parameters
        ----------
        context: str
            The existing model component to be duplicated.
        name: str
            The name of the duplicate. If this already exists then it will
            append a suffix to the name.
        use_template: Boolean
            Optional. Duplicate the item from the the catalog, if it exists.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Examples
        --------
        >>> model.copy(Well='Simple vertical', name='Sixgill', use_template=True)
        >>> model.copy(Name='Well01', name='Well01', use_template=False)

        """
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=None,
                                                model_context=None,
                                                context_keywords=None)

        _copy(merged_context, name, self, self._catalog, self._session, use_template)

    def connect(self, source, destination, source_port=None):
        """
        Connect the source item to the destination item

        Creates a connection from the source item to the destination item. It
        will fail if the source context or destination context match more than
        one item.

        Parameters
        ----------
        source : dict or context string
            The find context for the source item.

        destination : dict or context string
            The find context for the destination item.

        source_port : str
            If the source is a TwoPhaseSeparator or ThreePhaseSeparator, this
            is required to indicate which outlet should be used to make the
            connection, as provided by the Connection.Separator enumeration.

        Examples
        --------
        >>> connect(source={ModelComponent.Well:"Well 3"},
                    destination={"Choke":"TCV-03"})
        >>> connect(source="Sep-01", destination="ExportGasSink",
                    source_port=Connection.Separator.Top)

        """
        source_context = get_model_context(self.context, source)
        destination_context = get_model_context(self.context, destination)
        connect(self._catalog, self._session, source_context, destination_context, source_port)

    def disconnect(self, source, destination: Optional[str] = None, port: Optional[str] = None):
        """
        Disconnect the source and the destination components.

        Removes the connection between the source model component and the
        destination model component. Altenatively, specifying the source and
        the source port will break the connection from the specified port.
        The method will fail if the source or destination contexts do not
        exist or there is no connection between them.

        Parameters
        ----------
        source : dict or str
            The source model component (starting point for the connection). This
            can either be a context string or a context dictionary.

        destination : dict or str
            Optional. The destination model component (ending point of the connection).

        port : str
            Optional. The port to be disconnected on the source model component. Note
            that some model components (e.g. Junction, Heat Exchange, Choke) do
            not have indentifiable inlet and outlet ports hence should need to
            use the destination argument instead.

        Examples
        --------
        >>> disconnect(source={ModelComponent.Well:"Well 3"},
                       destination={Choke:"TCV-03"})
        >>> disconnect(source="Well 3", destination="TCV-03")

        """
        start_context = get_model_context(self.context, source)
        end_context = get_model_context(self.context, destination)
        disconnect(self._catalog, self._session, start_context, end_context)

    def connections(self,
                    context: Optional[str] = None,
                    component: Optional[str] = None,
                    model_context: Optional[AbstractModelContext] = None,
                    **context_keywords: str) -> List[Dict]:

        """
        Get the model component connections in the context.

        Returns the model component connections in the context. It is provided
        as a list of dictionaries with the Source, Destination and Source Port
        for easy revieiwng and formatting in a DataFrame. If no context is
        provided, then the information of all connections are returned.

        Parameters
        ----------
        context: str
            Optional. The context string to search for Source or Destination.
        component: str
            Optional. The model component to look for Source or Destination.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        List[Dict]
            Return a list of dictionaries. Each dictionary contains connection information
            including Source, Source Port, and Destination

        Examples
        --------
        >>> model.connections(Well=ALL)

        """
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=component,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        return connections(self._catalog, self._session, merged_context)

    def get_connections(self,
                    context: Optional[str] = None,
                    component: Optional[str] = None,
                    model_context: Optional[AbstractModelContext] = None,
                    **context_keywords: str) -> Dict:
        """
        Get the connections for each item in the context.

        Returns the connections for each item in the context. It is formatted
        as a dictionary of context, with each context providing the source,
        destination and the ports of the context items. It is therefore useful
        as a look-up table to find the inlets and outlets of specific model
        components. If no context is provided, then the information of all
        connections is returned.

        Parameters
        ----------
        context: str
            Optional. The context string to search for Source or Destination.
        component: str
            Optional. The model component to look for Source or Destination.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Returns
        -------
        Dict[Dict]
            Returns a dictionary of dictionaries. Each dictionary contains
            connection information including Source, Source Port, and Destination

        Examples
        --------
        >>> model.get_connections("MBD-101")

        """

        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=component,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        return get_connections(self._catalog, self._session, merged_context)

    def convert(self,
                context: Optional[str] = None,
                to_component: str = None,
                model_context: Optional[AbstractModelContext] = None,
                **context_keywords: str) -> Optional[DataFrame]:

        """
        Convert an item to the specified type of model component.

        Converts a junction to either a WellHead, Source or Sink. If more than
        one item matches the search context then it will fail.

        Parameters
        ----------
        context: str
            Optional. The context string to search in.
        to_component: str
            Required. The model component type to change the specified item
            into. This must be an enumeration of ModelComponents, though
            only WellHead, Source and Sink are supported at this time.
        model_context: AbstractModelContext
            Optional. The context to search in.
        context_keywords: str
            Comma separated list of context search criteria in the form of
            component='value', where component is the model component of the
            item, and value is the value of the model component. Values can
            also be ANY (matches any value) or NONE (matches no value).

        Examples
        --------
        >>> model.convert(component=ModelComponents.Junction, context="JN-01",
                          to_component=ModelComponents.WELL)

        """
        merged_context = getset.compute_context(root_context=self.context,
                                                context=context,
                                                component=ModelComponents.JUNCTION,
                                                model_context=model_context,
                                                context_keywords=context_keywords)

        convert(self._almanac, self._catalog, self._session, to_component, merged_context)

class _FilteredModel(Model):
    def __init__(self, model, context):
        """Initialize a filtered model"""
        self._unfiltered_model = model
        self._metadata = model._metadata
        self._almanac = model._almanac
        self._session = model._session
        self._catalog = model._catalog.filter(context)


class ModelAbout(object):
    """
    Provides details about the model, web API and Python Toolkit
    """

    def __init__(self, model):
        from sixgill.definitions import PYTHON_TOOLKIT_VERSION
        self._about = {
            Parameters.About.WEBAPIVERSION: model._session.web_api.WebApiAppVersion,
            Parameters.About.TOOLKITVERSION: PYTHON_TOOLKIT_VERSION,
            Parameters.About.MODELFILENAME: model._model_file,
            Parameters.About.UNITSYSTEM: model._unit_system,
            Parameters.About.UIUNITSYSTEM: model._ui_unit_system,
        }

    def __call__(self):
        """ Return the full about details """
        return self._about

    @property
    def webapi_version(self):
        """ The PIPESIM web API version """
        return self._about[Parameters.About.WEBAPIVERSION]

    @property
    def filename(self):
        """ The model folder and file name """
        return self._about[Parameters.About.MODELFILENAME]

    @property
    def toolkit_version(self):
        """ The PIPESIM Python Toolkit version """
        return self._about[Parameters.About.TOOLKITVERSION]

    @property
    def unit_system(self):
        """ The engineering unit system """
        return self._about[Parameters.About.UNITSYSTEM]

    
    @property
    def ui_unit_system(self):
        """ The engineering ui unit system """
        return self._about[Parameters.About.UIUNITSYSTEM]

class Task(object):

    def __init__(self, model):
        self._model = model
        self._network_simulation = NetworkSimulation(model, SimulationTypes.NETWORKSIMOPERATION)
        self._network_opt_simulation = NetworkOptimizerSimulation(model, SimulationTypes.NETWORKOPTIMIZEROPERATION)
        self._pt_simulation = PTProfileSimulation(model, SimulationTypes.PRESSURETEMPPROFILEOPERATION)
        self._nodal_analysis = NodalAnalysisSimulation(model, SimulationTypes.NODALANALYSIS)
        self._sa_simulation = SystemAnalysisSimulation(model, SimulationTypes.SYSTEMANALYSIS)
        self._wpc_simulation = WellPerformanceCurvesSimulation(model, SimulationTypes.WELLPERFORMANCECURVESOPERATION)
        self._gldiagnostics_simulation = GLDiagnosticsSimulation(model, SimulationTypes.GASLIFTDIAGNOSTICS)
        self._vfp_simulation = VfpTablesOperationSimulation(model, SimulationTypes.VFPTABLESROPERATION)

    @property
    def networksimulation(self):
        return self._network_simulation

    @property
    def networkoptimizersimulation(self):
        return self._network_opt_simulation

    @property
    def vfptablessimulation(self):
        return self._vfp_simulation

    @property
    def ptprofilesimulation(self):
        return self._pt_simulation

    @property
    def nodalanalysis(self):
        return self._nodal_analysis

    @property
    def wellperformancecurvessimulation(self):
        return self._wpc_simulation

    @property
    def systemanalysissimulation(self):
        return self._sa_simulation

    @property
    def gldiagnosticssimulation(self):
        return self._gldiagnostics_simulation


class NetworkSimulation(AbstractNetworkSimulation):

    def get_use_surface_conditions(self, study: Optional[str]=None):
        """
        Returns the value of use surface conditions.

        Returns the value of use surface conditions for the specified study.
        If the network simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        bool
            The value of use surface conditions.

        Examples
        --------
        >>> use_surface = model.tasks.networksimulation.get_use_surface_conditions()
        >>> use_surface = model.tasks.networksimulation.get_use_surface_conditions("Study 1")


        """
        task = get_or_create_network_sim_node(self._model, study)
        return task.UseSurfaceBoundaryConditions

    def set_use_surface_conditions(self, value: bool, study: Optional[str]=None):
        """
        Sets the value of use surface conditions.

        Sets the the value of use surface conditions for the specified study.
        If the network simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        value : bool
            The value of use surface conditions. If true, set to use surface conditions.
            If false, set to use reservoir conditions.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Examples
        --------
        >>> model.tasks.networksimulation.set_use_surface_conditions(True)
        >>> model.tasks.networksimulation.set_use_surface_conditions(False, study = "Study 1")

        """
        task = get_or_create_network_sim_node(self._model, study)
        task.UseSurfaceBoundaryConditions = value

    def get_conditions(self, use_surface_condition: Optional[bool] = None,
                       study: Optional[str] = None) -> Dict:
        """
        Returns the study conditions.

        Returns the network simulation conditions for the specified study.
        If the network simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        use_surface_condition : bool
            Optional. get surface conditions or reservoir conditions. If not provided,
            default is the conditions used in the model.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        dict
            The study conditions.

        Examples
        --------
        >>> studynetsim1 = model.tasks.networksimulation.get_conditions()
        >>> studynetsim1 = model.tasks.networksimulation.get_conditions("Study 1")
        >>> studynetsim1 = model.tasks.networksimulation.get_conditions(
                                use_surface_condition=True, study="Study 1")

        """
        return get_netsim_conditions(self._model, use_surface_condition, study)

    def set_conditions(self, boundaries: Optional[dict] = {}, constraints: Optional[dict] = {},
                        use_surface_condition: Optional[bool] = None,
                        study: Optional[str] = None):
        """
        Sets the study conditions.

        Sets the study conditions for the specified study.
        If the network simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        use_surface_condition : bool
            Optional. set surface conditions or reservoir conditions. If not provided,
            default is the conditions used in the model.
        boundaries : dict
            Optional. The boundary conditions to be set on the study.
        constraints : dict
            Optional. The rate constraints to be set on the study.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        Network simulation operation
            The existing or created network simulation operation.

        Examples
        --------
        >>> model.tasks.networksimulation.set_conditions(
                    boundaries={"Well:VertComp":{
                        Parameters.Boundary.PRESSURE:NAN,
                        Parameters.Boundary.TEMPERATURE:150,
                        Parameters.Boundary.FLOWRATETYPE:Constants.FlowRateType.GASFLOWRATE,
                        Parameters.Boundary.GASFLOWRATE:5}},
                    constraints={"Well":{Parameters.RateConstraint.LIQUIDFLOWRATE:200.0}})
        >>> model.tasks.networksimulation.set_conditions(use_surface_condition=False,
                    boundaries={"Well:VertComp":{
                                    Parameters.Boundary.PRESSURE:NAN,
                                    Parameters.Boundary.TEMPERATURE:150,
                                    Parameters.Boundary.FLOWRATETYPE:Constants.FlowRateType.GASFLOWRATE,
                                    Parameters.Boundary.GASFLOWRATE:5}},
                    study = "Study 1")

        """
        return set_netsim_conditions(self._model, use_surface_condition, boundaries, constraints, study)

    def reset_conditions(self, study: Optional[str] = None):
        """
        Resets the study conditions to be synchronized with the model.

        Resets the study conditions to be synchronized with the model for the specified study.

        Parameters
        ----------
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        bool
            Whether the reset succeeded (True) or not (False).

        Examples
        --------
        >>> model.tasks.networksimulation.reset_conditions()
        >>> model.tasks.networksimulation.reset_conditions(study = "Study 1")

        """
        return reset_netsim_conditions(self._model, study)
    
    
    def get_constraints(self, study: Optional[str] = None) -> Dict:
                       
        """
        Returns the study constraints.

        Returns the network simulation conditions for the specified study.
        If the network simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        dict
            The study conditions.

        Examples
        --------
        >>> studynetsim1 = model.tasks.networksimulation.get_constraints()
        >>> studynetsim1 = model.tasks.networksimulation.get_constraints("Study 1")

        """
        return get_netsim_constraints(self._model, study)
    

    def set_constraints(self, constraints,
                        study: Optional[str] = None):
        """
        Sets the study constraints.

        Sets the study constraints for the specified study.
        If the network simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        constraints : dict
            The constraints to be set on the study.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        Network simulation operation
            The existing or created network simulation operation.

        Examples
        --------
        >>> model.tasks.networksimulation.set_constraints(constraints={"Well":{Parameters.RateConstraint.LIQUIDFLOWRATE:200.0}})
        >>> model.tasks.networksimulation.set_constraints({"Well":{Parameters.RateConstraint.LIQUIDFLOWRATE:200.0}})
        >>> model.tasks.networksimulation.set_constraints(
                    constraints={"Well":{Parameters.RateConstraint.LIQUIDFLOWRATE:200.0}},
                    study = "Study 1")

        """
        return set_netsim_conditions(self._model, False, constraints=constraints, study=study)
    
    def delete_constraints(self, study: Optional[str] = None):
        """
        Deletes the study constraints.

        Parameters
        ----------
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        bool
            Whether the reset succeeded (True) or not (False).

        Examples
        --------
        >>> model.tasks.networksimulation.delete_constraints()
        >>> model.tasks.networksimulation.delete_constraints(study = "Study 1")

        """
        return delete_netsim_constraints(self._model, study=study)

    def generate_engine_files(self,
                            folder_path: Optional[str] = None,
                            study: Optional[str] = None) -> List[str]:
        """
        Create engine files for the specified study.

        Generate the engine file(s) for the requested study. The files are written
        to the specified folder, or to the current model folder if one is not given.

        Parameters
        ----------
        folder_path : str
            Optional. The folder location where the generated files are written to.
            If not specified, the files will be written to current pipesim model file folder.
        study : str
            Optional. The study name.

        Returns
        -------
        List[str]
            The list of engine files generated.

        Examples
        --------
        >>> engine_files = model.tasks.networksimulation.generate_engine_files()
        >>> engine_files = model.tasks.networksimulation.generate_engine_files(
                                   study='Study 1')
        >>> engine_files = model.tasks.networksimulation.generate_engine_files(
                                   folder_path="D:\\Temp", study='Study 1')
        """

        operation_context = compute_operation_context(root_context=self._model.context,
                                                      task=Tasks.NETWORKSIMULATION,
                                                      study=study,
                                                      model_context=None,
                                                      context_keywords=None)
        if not folder_path:
            folder_path = os.path.dirname(os.path.realpath(self._model._model_file))

        return generate(self._model._catalog, operation_context, folder_path)

    # def get_results(self, 
    #                 study: Optional[str] = None,
    #                 ):

    #        return _get_existing_results(SimulationTypes.NETWORKSIMOPERATION, self._model,None, study)

    def run(self, profile_variables: Optional[list] = None,
                    system_variables: Optional[list] = None,
                    boundaries: Optional[dict] = {},
                    constraints: Optional[dict] = {},
                    use_surface_condition: Optional[bool] = None,
                    study: Optional[str] = None,
                    options:Optional[dict] = {}):
        """
        Runs a network simulation.

        Runs a network simulation. Optionally the
        boundaries, constraints, and variables may be set at the same time
        avoiding the need to use set_conditions().
        If the network simulation task does not exist in the study, a new one will be created.
        The method waits until the simulation has finished before returning, and then returns
        the results.

        Parameters
        ----------
        use_surface_condition : bool
            Optional. use surface conditions or reservoir conditions. If not provided,
            default is the conditions used in the model.
        boundaries : dict
            Optional. The boundary conditions to be set on the study.
        constraints : dict
            Optional. The constraints to be set on the study.
        profile_variables : list
            Optional. The list of profile variables to be returned with the
            simulation profile results. If omitted then all the possible
            profile variables are returned.
        system_variables : list
            Optional. The list of system variables to be returned with the
            simulation system results. If omitted then all the possible
            system variables are returned.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.
        options : dict
            Optional. simulations options like generating ouput files and using Restart

        Returns
        -------
        dict
            The simulation results.

        Examples
        --------

        >>> sim_results = model.tasks.networksimulation.run(
                    use_surface_condition=False,
                    boundaries={"Well1.Comp1":{
                                        Parameters.Boundary.PRESSURE:NAN,
                                        Parameters.Boundary.LIQUIDFLOWRATE:200,
                                        Parameters.Boundary.FLOWRATETYPE:Constants.FlowRateType.LIQUIDFLOWRATE}
                                },
                    constraints={"Well":{Parameters.RateConstraint.LIQUIDFLOWRATE:200.0}},
                    profile_variables=OutputVariables.Profile.GAS_FIELD,
                    system_variables=OutputVariables.System.GAS_FIELD,
                    options={SimulationOptions.GENERATEOUTPUTFILE:True,
                            SimulationOptions.RESTART:False,
                            SimulationOptions.PARALLELISM:4})#generate output file, don't use restart files, run with 4 cores

        """
        return run_network_simulation(self._model, use_surface_condition=use_surface_condition,
                                         boundaries=boundaries, constraints=constraints, profile_variables=profile_variables,
                                         system_variables=system_variables, study=study, options=options)

    def start(self, profile_variables: Optional[list] = None,
                    system_variables: Optional[list] = None,
                    boundaries: Optional[dict] = {},
                    constraints: Optional[dict] = {},
                    use_surface_condition: Optional[bool] = None,
                    options:Optional[dict] = {},
                    study: Optional[str] = None) -> str:
        """
        Starts running a simulation of the specified type, returning the simulation id
        immediately which can be used later to check the status and get the results.
        If the network simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        use_surface_condition : bool
            Optional. use surface conditions or reservoir conditions. If not provided,
            default is the conditions used in the model.
        parameters : dict
            Optional. The parameters and respective values to set.
            For PT Profile, it must contain the name of the StartNode (Well or Source)
        boundaries : dict
            Optional. The boundary conditions to be set on the study.
        constraints : dict
            Optional. The constraints to be set on the study.
        sensitivities : dict
            Optional. For PT Profile simulations, the sensitivities.
        profile_variables : list
            Optional. The list of profile variables to be returned with the
            simulation profile results. If omitted then all the possible
            profile variables are returned.
        system_variables : list
            Optional. The list of system variables to be returned with the
            simulation system results. If omitted then all the possible
            system variables are returned.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.
        options : dict
            Optional. simulations options like generating ouput files and using Restart
        Returns
        -------
        str
            The simulation id, which can be used to access simulation status and get the results.

        Examples
        --------
        >>> sim_id = model.tasks.networksimulation.start(use_surface_condition=False,
                          boundaries={"Well1.Comp1":{
                                                Parameters.Boundary.PRESSURE:NAN,
                                                Parameters.Boundary.LIQUIDFLOWRATE:200,
                                                Parameters.Boundary.FLOWRATETYPE:Constants.FlowRateType.LIQUIDFLOWRATE}
                                      },
                          constraints={"Well":{Parameters.RateConstraint.LIQUIDFLOWRATE:200.0}},  
                          profile_variables=OutputVariables.Profile.GAS_FIELD,
                          system_variables=OutputVariables.System.GAS_FIELD,
                          options={SimulationOptions.GENERATEOUTPUTFILE:True,
                                    SimulationOptions.RESTART:False,
                                    SimulationOptions.PARALLELISM:4}) #generate output file, don't use restart files, run with 4 cores

        """
        return start_network_simulation(self._model, use_surface_condition=use_surface_condition,
                                         boundaries=boundaries,constraints=constraints, profile_variables=profile_variables,
                                         system_variables=system_variables, study=study,options=options)


class PTProfileSimulation(AbstractSingleBranchSimulation):

    def get_conditions(self, producer,
                       study: Optional[str] = None):
        """
        Returns the study conditions.

        Returns the PT profile simulation conditions for the specified study.
        If the PT profile simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the PT profile simulation task
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        dictZ 
            The PT profile settings in a dictionary format.

        Examples
        --------
        >>> studyptsim1 = model.tasks.ptprofilesimulation.get_conditions("Well 1")
        >>> studyptsim1 = model.tasks.ptprofilesimulation.get_conditions("Well 1",
                                   "Study 2")

        """
        return _get_pt_conditions(self._model, producer=producer, study=study)

    def set_conditions(self, producer, parameters={}, study: Optional[str] = None):
        """
        Sets the study conditions.

        Sets the PT profile simulation task conditions for the specified study.
        If the PT profile simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the PT profile simulation task.
        parameters : dict
            Required. The conditions for PT profile task to be set on the study.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        PT profile operation
            The existing or created PT profile operation.

        Examples
        --------
        >>> model.tasks.ptprofilesimulation.set_conditions("Well 1",
                    parameters={Parameters.PTProfileSimulation.INLETPRESSURE:3000,
                                Parameters.PTProfileSimulation.OUTLETPRESSURE:150,
                                Parameters.PTProfileSimulation.FLOWRATETYPE:Constants.FlowRateType.GASFLOWRATE,
                                Parameters.PTProfileSimulation.GASFLOWRATE:5})
        >>> model.tasks.ptprofilesimulation.set_conditions("Well 1",
                    parameters={Parameters.PTProfileSimulation.INLETPRESSURE:3000,
                                Parameters.PTProfileSimulation.OUTLETPRESSURE:150,
                                Parameters.PTProfileSimulation.FLOWRATETYPE:Constants.FlowRateType.GASFLOWRATE,
                                Parameters.PTProfileSimulation.GASFLOWRATE:5},
                    study="Study 2")

        """
        return _set_pt_conditions(self._model, producer=producer, parameters = parameters, study = study)

    def reset_conditions(self, producer, study: Optional[str] = None):
        """
        Resets the study conditions to be synchronized with the model.

        Resets the study conditions to be synchronized with the model for the specified study.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the PT profile simulation task.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        bool
            Whether the reset succeeded (True) or not (False).

        Examples
        --------
        >>> model.tasks.ptprofilesimulation.reset_conditions("Well 1")
        >>> model.tasks.ptprofilesimulation.reset_conditions(
                                            "Well 1", study = "Study 1")

        """
        return _reset_pt_sim_conditions(self._model, producer, study)


    def get_sensitivity_variables(self, producer, study: Optional[str] = None) -> List[str]:
        """
        Get the available sensitivity variable list.

        Get the list of possible sensitivity variables for the PT profile simulation task.
        If the PT profile simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the PT profile simulation task.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        list
            a list of sensitivity variables names that can be applied to this task.

        Examples
        --------
        >>> model.tasks.ptprofilesimulation.get_sensitivity_variables("Well 1")
        >>> model.tasks.ptprofilesimulation.get_sensitivity_variables("Well 1",
                          study="Study 2")

        """
        pt_sim_task = get_or_create_pt_sim_node(self._model, producer, study)
        sensitivity_variables = _get_possible_task_sens_variables(pt_sim_task)
        vars = defaultdict(list)
        for var in sensitivity_variables:
            k, v = var.Name.split('/')
            vars[k].append(v)
        return vars


    def get_calculated_variables(self, producer, study: Optional[str] = None) -> List[str]:
        """
        get the possible calculated variable list.

        Get the list of possible calculated variable for the PT profile simulation task.
        If the PT profile simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the PT profile simulation task.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        list
            a list of possible calculated variable names that can be applied to this task.

        Examples
        --------
        >>> model.tasks.ptprofilesimulation.get_calculated_variables("Well 1")
        >>> model.tasks.ptprofilesimulation.get_calculated_variables("Well 1",
                          study="Study 2")

        """
        pt_sim_task = get_or_create_pt_sim_node(self._model, producer, study)
        return [v.Name for v in _get_operation_sim_calc_variables(pt_sim_task)]

    def generate_engine_files(self,
                              producer,
                              folder_path: Optional[str] = None,
                              study: Optional[str] = None) -> List[str]:
        """
        Create engine files for the specified study.

        Generate the engine file(s) for the requested study. The files are written
        to the specified folder, or to the current model folder if one is not given.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the PT profile simulation task.
        folder_path : str
            Optional. The folder location where the generated files are written to.
            If not specified, the files will be written to current pipesim model folder.
        study : str
            Optional. The study name.

        Returns
        -------
        List[str]
            The list of engine files generated.

        Examples
        --------
        >>> engine_files = model.tasks.ptprofilesimulation.generate_engine_files(
                                    producer="Well 1")
        >>> engine_files = model.tasks.ptprofilesimulation.generate_engine_files(
                                    producer="Well 1", folder_path="D:\\Temp")
        >>> engine_files = model.tasks.ptprofilesimulation.generate_engine_files(
                                    producer="Well 1", folder_path="D:\\Temp",
                                    study="Study 1")
        """

        pt_sim_task = get_or_create_pt_sim_node(self._model, producer, study)
        operation_context = self._model._catalog.lookup_context_by_node(pt_sim_task)

        if not folder_path:
            folder_path = os.path.dirname(os.path.realpath(self._model._model_file))

        return generate(self._model._catalog, operation_context, folder_path)

    def run(self, producer, parameters={},
            profile_variables:Optional[list] = None,
            system_variables:Optional[list] = None,
            study: Optional[str] = None):
        """
        Runs a PT Profile simulation.

        Runs a PT Profile simulation. Optionally the
        parameters and variables may be set at the same time
        avoiding the need to use set_conditions().
        If the PT profile simulation task does not exist in the study, a new one will be created.
        The method waits until the simulation has finished before returning, and then returns
        the results.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the PT profile simulation task.
        parameters : dict
            Optional. The parameters and respective values to set.
        profile_variables : list
            Optional. The list of profile variables to be returned with the
            simulation profile results. If omitted then all the possible
            profile variables are returned.
        system_variables : list
            Optional. The list of system variables to be returned with the
            simulation system results. If omitted then all the possible
            system variables are returned.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.
        Returns
        -------
        dict
            The simulation results.

        Examples
        --------

        >>> sim_results = model.tasks.ptfilesimulation.run( "Well 1",
                parameters={Parameters.PTProfileSimulation.OUTLETPRESSURE:200,
                            Parameters.PTProfileSimulation.SENSITIVITYVARIABLE:
                    {Parameters.PTProfileSimulation.SensitivityVariable.VARIABLE:
                    "VertComp/ReservoirPressure",
                    Parameters.PTProfileSimulation.SensitivityVariable.VALUES:
                    [2000,3000,4000]}
                }
                profile_variables=OutputVariables.Profile.GAS_FIELD,
                system_variables=OutputVariables.System.GAS_FIELD)

        """
        return _run_ptprofile_simulation(self._model, producer=producer, parameters=parameters, profile_variables=profile_variables,
                                          system_variables=system_variables, study=study)

    #def get_results(self, producer, parameters={},
    #        profile_variables:Optional[list] = None,
    #        system_variables:Optional[list] = None,
    #        study: Optional[str] = None):

    #        return _get_existing_results(SimulationTypes.PRESSURETEMPPROFILEOPERATION, self._model,producer, study)

    def start(self, producer, parameters={},
              profile_variables:Optional[list] = None,
              system_variables:Optional[list] = None,
              study: Optional[str] = None):
        """
        Starts running a PT Profile simulation, returning the simulation id
        immediately which can be used later to check the status and get the results
        If the PT profile simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the PT profile simulation task.
        parameters : dict
            Optional. The parameters and respective values to set.
        profile_variables : list
            Optional. The list of profile variables to be returned with the
            simulation profile results. If omitted then all the possible
            profile variables are returned.
        system_variables : list
            Optional. The list of system variables to be returned with the
            simulation system results. If omitted then all the possible
            system variables are returned.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        str
            The simulation id, which can be used to access simulation status and get the results.

        Examples
        --------
        >>> sim_id = model.tasks.ptfilesimulation.start( "Well 1",
                parameters={Parameters.PTProfileSimulation.OUTLETPRESSURE:200,
                            Parameters.PTProfileSimulation.SENSITIVITYVARIABLE:
                    {Parameters.PTProfileSimulation.SensitivityVariable.VARIABLE:
                    "VertComp/ReservoirPressure",
                    Parameters.PTProfileSimulation.SensitivityVariable.VALUES:
                    [2000,3000,4000]}
                            }
                profile_variables=OutputVariables.Profile.GAS_FIELD,
                system_variables=OutputVariables.System.GAS_FIELD)

        """
        return _start_ptprofile_simulation(self._model, producer=producer,
                                           parameters=parameters,
                                           profile_variables=profile_variables,
                                           system_variables=system_variables,
                                           study=study)


class GLDiagnosticsSimulation(AbstractSingleBranchSimulation):

    def get_conditions(self, producer,
                       study: Optional[str] = None):
        """
        Returns the study conditions.

        Returns the GLDiagnostics simulation conditions for the specified study.
        If the GLDiagnostics simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the GLDiagnostics simulation task
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        dictZ 
            The GLDiagnostics settings in a dictionary format.

        Examples
        --------
        >>> studyptsim1 = model.tasks.gldiagnosticssimulation.get_conditions("Well 1")
        >>> studyptsim1 = model.tasks.gldiagnosticssimulation.get_conditions("Well 1",
                                   "Study 2")

        """
        return _get_gldiagnostics_conditions(self._model, producer=producer, study=study)

    def set_conditions(self, producer, parameters={}, boundaries: Optional[dict] = {}, study: Optional[str] = None):
        """
        Sets the study conditions.

        Sets the GLDiagnostics simulation task conditions for the specified study.
        If the GLDiagnostics simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the GLDiagnostics simulation task.
        parameters : dict
            Required. The conditions for GLDiagnostics task to be set on the study.
        boundaries : dict
            Optional. The boundary conditions to be set on the study.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        GLDiagnostics operation
            The existing or created GLDiagnostics operation.

        Examples
        --------
        >>> model.tasks.gldiagnosticssimulation.set_conditions("Well 1",
                    parameters={Parameters.GLDiagnosticsSimulation.OUTLETPRESSURE:150,
                                Parameters.GLDiagnosticsSimulation.SURFACEINJECTIONPRESSURE:1750,
                                Parameters.GLDiagnosticsSimulation.TARGETINJECTIONRATE: 2.5})
        >>> model.tasks.gldiagnosticssimulation.set_conditions("Well 1",
                    parameters={Parameters.GLDiagnosticsSimulation.OUTLETPRESSURE:150,
                                Parameters.GLDiagnosticsSimulation.SURFACEINJECTIONPRESSURE:1750,
                                Parameters.GLDiagnosticsSimulation.TARGETINJECTIONRATE: 2.5},
                    study="Study 2")

        """
        return _set_gldiagnostics_conditions(self._model, producer=producer, parameters = parameters, boundaries=boundaries, study = study)

    def reset_conditions(self, producer, study: Optional[str] = None):
        """
        Resets the study conditions to be synchronized with the model.

        Resets the study conditions to be synchronized with the model for the specified study.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the GLDiagnostics simulation task.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        bool
            Whether the reset succeeded (True) or not (False).

        Examples
        --------
        >>> model.tasks.gldiagnosticssimulation.reset_conditions("Well 1")
        >>> model.tasks.gldiagnosticssimulation.reset_conditions(
                                            "Well 1", study = "Study 1")

        """
        return  _reset_gldiagnostics_conditions(self._model, producer, study)


    def get_sensitivity_variables(self, producer, study: Optional[str] = None) -> List[str]:
        """
        Get the available sensitivity variable list.

        Get the list of possible sensitivity variables for the GLDiagnostics simulation task.
        If the GLDiagnostics simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the GLDiagnostics simulation task.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        list
            a list of sensitivity variables names that can be applied to this task.

        Examples
        --------
        >>> model.tasks.gldiagnosticssimulation.get_sensitivity_variables("Well 1")
        >>> model.tasks.gldiagnosticssimulation.get_sensitivity_variables("Well 1",
                          study="Study 2")

        """
        gld_sim_task = get_or_create_gldiagnostics_sim_node(self._model, producer, study)
        sensitivity_variables = _get_possible_task_sens_variables(gld_sim_task)
        vars = defaultdict(list)
        for var in sensitivity_variables:
            k, v = var.Name.rsplit('/', 1)
            vars[k].append(v)
        return vars


    def generate_engine_files(self, producer,
                              folder_path: Optional[str] = None,
                              study: Optional[str] = None) -> List[str]:
        """
        Create engine files for the specified study.

        Generate the engine file(s) for the requested study. The files are written
        to the specified folder, or to the current model folder if one is not given.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the GLDiagnostics simulation task.
        folder_path : str
            Optional. The folder location where the generated files are written to.
            If not specified, the files will be written to current pipesim model folder.
        study : str
            Optional. The study name.

        Returns
        -------
        List[str]
            The list of engine files generated.

        Examples
        --------
        >>> engine_files = model.tasks.gldiagnosticssimulation.generate_engine_files(
                                    producer="Well 1")
        >>> engine_files = model.tasks.gldiagnosticssimulation.generate_engine_files(
                                    producer="Well 1", folder_path="D:/Temp")
        >>> engine_files = model.tasks.gldiagnosticssimulation.generate_engine_files(
                                    producer="Well 1", folder_path="D:/Temp",
                                    study="Study 1")
        """

        gld_sim_task = get_or_create_gldiagnostics_sim_node(self._model, producer, study)
        operation_context = self._model._catalog.lookup_context_by_node(gld_sim_task)

        if not folder_path:
            folder_path = os.path.dirname(os.path.realpath(self._model._model_file))

        return generate(self._model._catalog, operation_context, folder_path)

    def run(self, producer, parameters={},
            boundaries:Optional[dict] = {},
            profile_variables:Optional[list] = None,
            system_variables:Optional[list] = None,
            study: Optional[str] = None):
        """
        Runs a GLDiagnostics simulation.

        Runs a GLDiagnostics simulation. Optionally the
        parameters and variables may be set at the same time
        avoiding the need to use set_conditions().
        If the GLDiagnostics simulation task does not exist in the study, a new one will be created.
        The method waits until the simulation has finished before returning, and then returns
        the results.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the GLDiagnostics simulation task.
        parameters : dict
            Optional. The parameters and respective values to set.
        boundaries : dict
            Optional. The boundary conditions to be set on the study.
        profile_variables : list
            Optional. The list of profile variables to be returned with the
            simulation profile results. If omitted then all the possible
            profile variables are returned.
        system_variables : list
            Optional. The list of system variables to be returned with the
            simulation system results. If omitted then all the possible
            system variables are returned.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.
       
        Returns
        -------
        dict
            The simulation results.

        Examples
        --------

        >>> sim_results = model.tasks.gldiagnosticssimulation.run( "Well 1",
                parameters={Parameters.GLDiagnosticsSimulation.OUTLETPRESSURE:200,
                            Parameters.GLDiagnosticsSimulation.SENSITIVITYVARIABLE:
                    {Parameters.GLDiagnosticsSimulation.SensitivityVariable.VARIABLE:
                    "VertComp/ReservoirPressure",
                    Parameters.GLDiagnosticsSimulation.SensitivityVariable.VALUES:
                    [2000,3000,4000]}
                }
                profile_variables=OutputVariables.Profile.GAS_FIELD,
                system_variables=OutputVariables.System.GAS_FIELD)

        """
        return _run_gldiagnostics_simulation(self._model,
                                            producer=producer,
                                            parameters=parameters,
                                            boundaries=boundaries,
                                            profile_variables=profile_variables,
                                            system_variables=system_variables,
                                            study=study)

    def start(self, producer, parameters={},
              boundaries:Optional[dict] = {},
              profile_variables:Optional[list] = None,
              system_variables:Optional[list] = None,
              study: Optional[str] = None):
        """
        Starts running a GLDiagnostics simulation, returning the simulation id
        immediately which can be used later to check the status and get the results
        If the GLDiagnostics simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the GLDiagnostics simulation task.
        parameters : dict
            Optional. The parameters and respective values to set.
        boundaries : dict
            Optional. The boundary conditions to be set on the study.
        profile_variables : list
            Optional. The list of profile variables to be returned with the
            simulation profile results. If omitted then all the possible
            profile variables are returned.
        system_variables : list
            Optional. The list of system variables to be returned with the
            simulation system results. If omitted then all the possible
            system variables are returned.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        str
            The simulation id, which can be used to access simulation status and get the results.

        Examples
        --------
        >>> sim_id = model.tasks.gldiagnosticssimulation.start( "Well 1",
                parameters={Parameters.GLDiagnosticsSimulation.OUTLETPRESSURE:200,
                            Parameters.GLDiagnosticsSimulation.SENSITIVITYVARIABLE:
                    {Parameters.GLDiagnosticsSimulation.SensitivityVariable.VARIABLE:
                    "VertComp/ReservoirPressure",
                    Parameters.GLDiagnosticsSimulation.SensitivityVariable.VALUES:
                    [2000,3000,4000]}
                            }
                profile_variables=OutputVariables.Profile.GAS_FIELD,
                system_variables=OutputVariables.System.GAS_FIELD)

        """
        return _start_gldiagnostics_simulation(self._model, producer=producer,
                                           parameters=parameters,
                                           profile_variables=profile_variables,
                                           system_variables=system_variables,
                                           boundaries=boundaries,
                                           study=study)


class SystemAnalysisSimulation(AbstractSingleBranchSimulation):

    def get_conditions(self, producer,
                       study: Optional[str] = None):
        """
        Returns the study conditions.

        Returns the System analysis simulation conditions for the specified study.
        If the System analysis task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the System analysis simulation task
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        dictZ 
            The System analysis settings in a dictionary format.

        Examples
        --------
        >>> studyptsim1 = model.tasks.systemanalysissimulation.get_conditions("Well 1")
        >>> studyptsim1 = model.tasks.systemanalysissimulation.get_conditions("Well 1",
                                   "Study 2")

        """
        return _get_sa_conditions(self._model, producer=producer, study=study)

    def set_conditions(self, producer, parameters={}, study: Optional[str] = None):
        """
        Sets the study conditions.

        Sets the System analysis simulation task conditions for the specified study.
        If the System analysis simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the System analysis simulation task.
        parameters : dict
            Required. The conditions for System analysis task to be set on the study.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        System analysis operation
            The existing or created System analysis operation.

        Examples
        --------
        >>> model.tasks.systemanalysissimulation.set_conditions("Well 1",
                    parameters={Parameters.SystemAnalysisSimulation.INLETPRESSURE:3000,
                                Parameters.SystemAnalysisSimulation.OUTLETPRESSURE:150,
                                Parameters.SystemAnalysisSimulation.FLOWRATETYPE:Constants.FlowRateType.GASFLOWRATE,
                                Parameters.SystemAnalysisSimulation.LIQUIDFLOWRATE:5})
        >>> model.tasks.systemanalysissimulation.set_conditions("Well 1",
                    parameters={Parameters.SystemAnalysisSimulation.INLETPRESSURE:3000,
                                Parameters.SystemAnalysisSimulation.OUTLETPRESSURE:150,
                                Parameters.SystemAnalysisSimulation.FLOWRATETYPE:Constants.FlowRateType.GASFLOWRATE,
                                Parameters.SystemAnalysisSimulation.LIQUIDFLOWRATE:5},
                    study="Study 2")

        """
        return _set_sa_conditions(self._model, producer=producer, parameters = parameters, study = study)

    def reset_conditions(self, producer, study: Optional[str] = None):
        """
        Resets the study conditions to be synchronized with the model.

        Resets the study conditions to be synchronized with the model for the specified study.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the System analysis simulation task.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        bool
            Whether the reset succeeded (True) or not (False).

        Examples
        --------
        >>> model.tasks.systemanalysissimulation.reset_conditions("Well 1")
        >>> model.tasks.systemanalysissimulation.reset_conditions(
                                            "Well 1", study = "Study 1")

        """
        return _reset_sa_sim_conditions(self._model, producer, study)


    def get_calculated_variables(self, producer, study: Optional[str] = None) -> List[str]:
        """
        get the possible calculated variable list.

        Get the list of possible calculated variable for the System analysis simulation task.
        If the System analysis simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the System analysis simulation task.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        list
            a list of possible calculated variable names that can be applied to this task.

        Examples
        --------
        >>> model.tasks.systemanalysissimulation.get_calculated_variables("Well 1")
        >>> model.tasks.systemanalysissimulation.get_calculated_variables("Well 1",
                          study="Study 2")

        """
        sa_sim_task = get_or_create_sa_sim_node(self._model, producer, study)
        return [v.Name for v in _get_operation_sim_calc_variables(sa_sim_task)]

    def get_sensitivity_variables(self, producer, study: Optional[str] = None) -> List[str]:
        """
        Get the available sensitivity variable list.

        Get the list of possible sensitivity variables for the System analysis simulation task.
        If the System analysis simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the System analysis simulation task.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        list
            a list of sensitivity variables names that can be applied to this task.

        Examples
        --------
        >>> model.tasks.systemanalysissimulation.get_sensitivity_variables("Well 1")
        >>> model.tasks.systemanalysissimulation.get_sensitivity_variables("Well 1",
                          study="Study 2")

        """
        sa_sim_task = get_or_create_sa_sim_node(self._model, producer, study)
        sensitivity_variables = _get_possible_task_sens_variables(sa_sim_task)
        vars = defaultdict(list)
        for var in sensitivity_variables:
            k, v = var.Name.split('/')
            vars[k].append(v)
        return vars

    def generate_engine_files(self, producer,
                              folder_path: Optional[str] = None,
                              study: Optional[str] = None) -> List[str]:
        """
        Create engine files for the specified study.

        Generate the engine file(s) for the requested study. The files are written
        to the specified folder, or to the current model folder if one is not given.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the System analysis simulation task.
        folder_path : str
            Optional. The folder location where the generated files are written to.
            If not specified, the files will be written to current pipesim model folder.
        study : str
            Optional. The study name.

        Returns
        -------
        List[str]
            The list of engine files generated.

        Examples
        --------
        >>> engine_files = model.tasks.systemanalysissimulation.generate_engine_files(
                                    producer="Well 1")
        >>> engine_files = model.tasks.systemanalysissimulation.generate_engine_files(
                                    producer="Well 1", folder_path="D:/Temp")
        >>> engine_files = model.tasks.systemanalysissimulation.generate_engine_files(
                                    producer="Well 1", folder_path="D:/Temp",
                                    study="Study 1")
        """

        sa_sim_task = get_or_create_sa_sim_node(self._model, producer, study)
        operation_context = self._model._catalog.lookup_context_by_node(sa_sim_task)

        if not folder_path:
            folder_path = os.path.dirname(os.path.realpath(self._model._model_file))

        return generate(self._model._catalog, operation_context, folder_path)

    def run(self, producer,
            parameters={},
            profile_variables:Optional[list] = None,
            system_variables:Optional[list] = None,
            study: Optional[str] = None):
        """
        Runs a System analysis simulation.

        Runs a System analysis simulation. Optionally the
        parameters and variables may be set at the same time
        avoiding the need to use set_conditions().
        If the System analysis simulation task does not exist in the study, a new one will be created.
        The method waits until the simulation has finished before returning, and then returns
        the results.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the System analysis simulation task.
        parameters : dict
            Optional. The parameters and respective values to set.
        profile_variables : list
            Optional. The list of profile variables to be returned with the
            simulation profile results. If omitted then all the possible
            profile variables are returned.
        system_variables : list
            Optional. The list of system variables to be returned with the
            simulation system results. If omitted then all the possible
            system variables are returned.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        dict
            The simulation results.

        Examples
        --------

        >>> sim_results = model.tasks.systemanalysissimulation.run( "Well 1",
                parameters={Parameters.SystemAnalysisSimulation.OUTLETPRESSURE:200,
                            Parameters.SystemAnalysisSimulation.SENSITIVITYVARIABLE:
                    {Parameters.SystemAnalysisSimulation.SensitivityVariable.VARIABLE:
                    "VertComp/ReservoirPressure",
                    Parameters.SystemAnalysisSimulation.SensitivityVariable.VALUES:
                    [2000,3000,4000]}
                }
                profile_variables=OutputVariables.Profile.GAS_FIELD,
                system_variables=OutputVariables.System.GAS_FIELD)

        """
        return _run_systemanalysis_simulation(self._model, producer=producer, parameters=parameters, profile_variables=profile_variables,
                                          system_variables=system_variables, study=study)

    def start(self, producer,
              parameters={},
              profile_variables:Optional[list] = None,
              system_variables:Optional[list] = None,
              study: Optional[str] = None):
        """
        Starts running a System analysis simulation, returning the simulation id
        immediately which can be used later to check the status and get the results
        If the System analysis simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the System analysis simulation task.
        parameters : dict
            Optional. The parameters and respective values to set.
        profile_variables : list
            Optional. The list of profile variables to be returned with the
            simulation profile results. If omitted then all the possible
            profile variables are returned.
        system_variables : list
            Optional. The list of system variables to be returned with the
            simulation system results. If omitted then all the possible
            system variables are returned.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        str
            The simulation id, which can be used to access simulation status and get the results.

        Examples
        --------
        >>> sim_id = model.tasks.systemanalysissimulation.start( "Well 1",
                parameters={Parameters.SystemAnalysisSimulation.OUTLETPRESSURE:200,
                            Parameters.SystemAnalysisSimulation.SENSITIVITYVARIABLE:
                                {Parameters.SystemAnalysisSimulation.SensitivityVariable.VARIABLE:"VertComp/ReservoirPressure",
                                 Parameters.SystemAnalysisSimulation.SensitivityVariable.VALUES:[2000,3000,4000]
                                 }
                            }
                profile_variables=OutputVariables.Profile.GAS_FIELD,
                system_variables=OutputVariables.System.GAS_FIELD)

        """
        return _start_systemanalysis_simulation(self._model, producer=producer,
                                           parameters=parameters,
                                           profile_variables=profile_variables,
                                           system_variables=system_variables,
                                           study=study)


class WellPerformanceCurvesSimulation(AbstractSingleBranchSimulation):

    def get_conditions(self, producer,
                       study: Optional[str] = None):
        """
        Returns the study conditions.

        Returns the Well performance curves simulation conditions for the specified study.
        If the Well performance curves simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the Well performance curves simulation task
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        dict
            The Well performance curves settings in a dictionary format.

        Examples
        --------
        >>> studyptsim1 = model.tasks.wellperformancecurvessimulation.get_conditions("Well 1")
        >>> studyptsim1 = model.tasks.wellperformancecurvessimulation.get_conditions("Well 1",
                                   "Study 2")

        """
        return _get_wc_conditions(self._model, producer=producer, study=study)

    def set_conditions(self, producer, parameters={}, study: Optional[str] = None):
        """
        Sets the study conditions.

        Sets the Well performance curves simulation task conditions for the specified study.
        If the Well performance curves simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the Well performance curves simulation task.
        parameters : dict
            Required. The conditions for Well performance curves task to be set on the study.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        Well performance curves operation
            The existing or created Well performance curves operation.

        Examples
        --------
        >>> model.tasks.wellperformancecurvessimulation.set_conditions("Well 1", parameters=studyptsim1)
        >>> model.tasks.wellperformancecurvessimulation.set_conditions("Well 1", parameters=studyptsim1,
                                   "Study 2")

        """
        return _set_wc_conditions(self._model, producer=producer, parameters = parameters, study = study)


    def get_sensitivity_variables(self, producer, study: Optional[str] = None) -> List[str]:
        """
        Get the available sensitivity variable list.

        Get the list of possible sensitivity variables for the Well performance curves simulation task.
        If the Well performance curves simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the Well performance curves simulation task.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        list
            a list of sensitivity variables names that can be applied to this task.

        Examples
        --------
        >>> model.tasks.wellperformancecurvessimulation.get_sensitivity_variables("Well 1")
        >>> model.tasks.wellperformancecurvessimulation.get_sensitivity_variables("Well 1",
                          study="Study 2")

        """
        wc_sim_task = get_or_create_wc_sim_node(self._model, producer, study)
        sensitivity_variables = _get_possible_task_sens_variables(wc_sim_task)
        vars = defaultdict(list)
        for var in sensitivity_variables:
            k, v = var.Name.split('/')
            vars[k].append(v)
        return vars

    def generate_engine_files(self,
                              producer,
                              folder_path: Optional[str] = None,
                              study: Optional[str] = None) -> List[str]:
        """
        Create engine files for the specified study.

        Generate the engine file(s) for the requested study. The files are written
        to the specified folder, or to the current model folder if one is not given.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the Well performance curves simulation task.
        folder_path : str
            Optional. The folder location where the generated files are written to.
            If not specified, the files will be written to current pipesim model folder.
        study : str
            Optional. The study name.

        Returns
        -------
        List[str]
            The list of engine files generated.

        Examples
        --------
        >>> engine_files = model.tasks.wellperformancecurvessimulation.generate_engine_files(
                                    producer="Well 1")
        >>> engine_files = model.tasks.wellperformancecurvessimulation.generate_engine_files(
                                    producer="Well 1", folder_path="D:\\Temp")
        >>> engine_files = model.tasks.wellperformancecurvessimulation.generate_engine_files(
                                    producer="Well 1", folder_path="D:\\Temp",
                                    study="Study 1")
        """

        wc_sim_task = get_or_create_wc_sim_node(self._model, producer, study)
        operation_context = self._model._catalog.lookup_context_by_node(wc_sim_task)

        if not folder_path:
            folder_path = os.path.dirname(os.path.realpath(self._model._model_file))

        return generate(self._model._catalog, operation_context, folder_path)

    def run(self, producer, parameters={},
            system_variables:Optional[list] = None,
            study: Optional[str] = None):
        """
        Runs a Well performance curves simulation.

        Runs a Well performance curves simulation. Optionally the
        parameters and variables may be set at the same time
        avoiding the need to use set_conditions().
        If the Well performance curves simulation task does not exist in the study, a new one will be created.
        The method waits until the simulation has finished before returning, and then returns
        the results.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the Well performance curves simulation task.
        parameters : dict
            Optional. The parameters and respective values to set.
        system_variables : list
            Optional. The list of system variables to be returned with the
            simulation system results. If omitted then all the possible
            system variables are returned.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.
        Returns
        -------
        dict
            The simulation results.

        Examples
        --------

        >>> sim_results = model.tasks.wellperformancecurvessimulation.run( "Well 1")
                
        """
        return _run_wc_simulation(self._model, producer=producer, parameters=parameters, profile_variables=None,
                                  system_variables=system_variables, study=study)

    def start(self, producer, parameters={},
              system_variables:Optional[list] = None,
              study: Optional[str] = None):
        """
        Starts running a Well performance curves simulation, returning the simulation id
        immediately which can be used later to check the status and get the results
        If the Well performance curves simulation task does not exist in the study, a new one will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the Well performance curves simulation task.
        parameters : dict
            Optional. The parameters and respective values to set.
        system_variables : list
            Optional. The list of system variables to be returned with the
            simulation system results. If omitted then all the possible
            system variables are returned.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        str
            The simulation id, which can be used to access simulation status and get the results.

        Examples
        --------
        >>> sim_id = model.tasks.wellperformancecurvessimulation.start( "Well 1")

        """
        return _start_wc_simulation(self._model, producer=producer, parameters=parameters, profile_variables=None,
                                        system_variables=system_variables, study=study)


class NodalAnalysisSimulation(AbstractSingleBranchSimulation):

    def get_conditions(self, producer,
                       nodal_point_settings: Optional[dict] = None,
                       study: Optional[str] = None):
        """
        Returns the nodal analysis general conditions in one dictionary and inlet condtions in anohter dictionary.

        Returns the nodal analysis general conditions for the specified study.
        If the nodal analysis task does not exist in the study, a new one will be created. If the producer is a 
        well and nodal point settings are not provided, a default nodal point at bottom hole will be created. 
        If nodal point settings are provided, a new nodal point will be created and be applied to the existing or 
        newly created nodal analysis task. 

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the nodal analysis simulation task
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.
        nodal_point_settings: dict
            Optional. The settings for nodal point to be created. The new nodal point is applied to the 
            existing or newly created nodal analysis task.  

        Returns
        -------
        dict
            Nodal analysis simulation settings in the first dictionary, and inlet conditions in the second dictionary

        Examples
        --------
        >>> na_sim, inlet_cond = model.tasks.nodalanalysis.get_conditions("Well 1")
        >>> na_sim, inlet_cond = model.tasks.nodalanalysis.get_conditions(
            "Well 1", 
            nodal_point_settings = {
            Parameters.NodalPoint.NODALTYPE: Constants.NodalPointType.SURFACE,
            Parameters.NodalPoint.EQUIPMENT: 'Choke',
            Parameters.NodalPoint.NAME: 'NA1'
            })
        >>> na_sim, inlet_cond = model.tasks.nodalanalysis.get_conditions(
            "Well 1", "Study 2", 
            nodal_point_settings = {
            Parameters.NodalPoint.NODALTYPE: Constants.NodalPointType.DOWNHOLE,
            Parameters.NodalPoint.DEPTH: 1000,
            Parameters.NodalPoint.WELLSTRINGTYPE: Constants.TubingSectionType.TUBING,
            Parameters.NodalPoint.NAME: 'NA2'
            })
        """
        return _get_na_conditions(self._model, producer=producer,
                                  study=study,
                                  nodal_point_settings=nodal_point_settings)

    def set_conditions(self, producer, parameters={}, inlet_conditions: Optional[dict]=None,
                       nodal_point_settings: Optional[dict] = None, study: Optional[str] = None):
        """
        Sets the study conditions.

        Sets the nodal analysis profile simulation task conditions for the specified study.
        If the nodal analysis simulation task does not exist in the study, a new one will be created.If the producer is a 
        well and nodal point settings are not provided, a default nodal point at bottom hole will be created. 
        If nodal point settings are provided, a new nodal point will be created and be applied to the existing or 
        newly created nodal analysis task. 

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the nodal analysis simulation task.
        parameters : dict
            Required. The conditions for nodal analysis task to be set on the study.
        inlet_conditions: dict
            Optional. The inlet conditions for nodal analysis task to be set on the study. 
        nodal_point_settings: dict
            Optional. The settings for nodal point to be created. The new nodal point is applied to the 
            existing or newly created nodal analysis task.  
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.
        Returns
        -------
        Nodal analysis operation
            The exisitng or created nodal analysis operation 

        Examples
        --------
        >>> model.tasks.nodalanalysis.set_conditions("Well 1",
                parameters={
                Parameters.NodalAnalysisSimulation.LIMITINFLOW: True,
                Parameters.NodalAnalysisSimulation.LIMITOUTFLOW: False,
                Parameters.NodalAnalysisSimulation.OUTFLOWPOINTS: 40,
                Parameters.NodalAnalysisSimulation.INFLOWPOINTS: 50,
                Parameters.NodalAnalysisSimulation.MAXFLOWRATETYPE: 
                                        Constants.FlowRateType.GASFLOWRATE,
                Parameters.NodalAnalysisSimulation.OUTLETPRESSURE: 3000,
                Parameters.NodalAnalysisSimulation.MAXGASRATE: 300,
                Parameters.NodalAnalysisSimulation.MAXOUTFLOWPRESSURE: 400,
                Parameters.NodalAnalysisSimulation.BRANCHTERMINATOR: "Choke"
                },
                inlet_conditions={
                    "Well1.Comp1":{Parameters.Boundary.PRESSURE:4000,
                                    Parameters.Boundary.TEMPERATURE:200}
                },
                nodal_point_settings={
                Parameters.NodalPoint.NODALTYPE: Constants.NodalPointType.DOWNHOLE,
                Parameters.NodalPoint.DEPTH: 1000,
                Parameters.NodalPoint.WELLSTRINGTYPE: Constants.TubingSectionType.TUBING,
                Parameters.NodalPoint.NAME: 'NA2'
                }
            )
        >>> model.tasks.nodalanalysis.set_conditions(
                producer="Well 1", study="Study 2", 
                parameters={
                    Parameters.NodalAnalysisSimulation.OUTLETPRESSURE: 3000,
                    Parameters.NodalAnalysisSimulation.BRANCHTERMINATOR: "Choke"
                    Parameters.NodalAnalysisSimulation.NODALMEASUREMENTPOINT: "NA2"
                })
        >>> model.tasks.nodalanalysis.set_conditions(
                producer="Well 1", study="Study 2",
                nodal_point_settings = {
                    Parameters.NodalPoint.NODALTYPE: Constants.NodalPointType.SURFACE,
                    Parameters.NodalPoint.EQUIPMENT: 'Choke',
                    Parameters.NodalPoint.NAME: 'NA4'
                })

        """
        return _set_na_conditions(self._model, producer, study, parameters,
                                  inlet_conditions, nodal_point_settings)

    def reset_conditions(self, producer, study: Optional[str] = None):
        """
        Resets the study conditions to be synchronized with the model.

        Resets the study conditions to be synchronized with the model for the specified study.
        

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the nodal analysis simulation task.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        bool
            Whether the reset succeeded (True) or not (False).

        Examples
        --------
        >>> model.tasks.nodalanalysis.reset_conditions("Well 1")
        >>> model.tasks.nodalanalysis.reset_conditions("Well 1",study = "Study 1")

        """
        return _reset_nodal_conditions(self._model, producer, study)
       

    def run(self, producer, parameters={},
            inlet_conditions: Optional[dict]=None,
            nodal_point_settings: Optional[dict] = None,
            profile_variables: Optional[list] = None,
            system_variables: Optional[list] = None,
            study: Optional[str] = None):
        """
        Runs a nodal analysis simulation.

        Runs a nodal analysis simulation. Optionally the parameters, nodal point settings and variables 
        may be set at the same time avoiding the need to use set_conditions().
        If the nodal analysis task does not exist in the study, a new one will be created.
        The method waits until the simulation has finished before returning, and then returns
        the results.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the nodal analysis simulation task.
        parameters : dict
            Optional. The parameters and respective values to set.
        nodal_point_settings: dict
            Optional. The settings for nodal point to be created. The new nodal point is 
            applied to the existing or newly created nodal analysis task.  
        profile_variables : list
            Optional. The list of profile variables to be returned with the
            simulation profile results. If omitted then all the possible
            profile variables are returned.
        system_variables : list
            Optional. The list of system variables to be returned with the
            simulation system results. If omitted then all the possible
            system variables are returned.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        dict
            The simulation results.

        Examples
        --------

        >>> sim_results = model.tasks.nodalanalysis.run( "Well 1",
                parameters={
                    Parameters.NodalAnalysisSimulation.OUTLETPRESSURE: 3000,
                    Parameters.NodalAnalysisSimulation.BRANCHTERMINATOR: "Choke"
                }
                nodal_point_settings = {
                    Parameters.NodalPoint.NODALTYPE: Constants.NodalPointType.SURFACE,
                    Parameters.NodalPoint.EQUIPMENT: 'Choke',
                    Parameters.NodalPoint.NAME: 'NA4'
                }
                profile_variables=OutputVariables.Profile.GAS_FIELD,
                system_variables=OutputVariables.System.GAS_FIELD)

        """
        return _run_na_simulation(self._model, producer=producer, nodal_point_settings=nodal_point_settings,
                                  parameters=parameters, inlet_conditions=inlet_conditions, profile_variables=profile_variables,
                                  system_variables=system_variables, study=study)

    def start(self, producer, parameters={},
              inlet_conditions: Optional[dict]=None,
              nodal_point_settings: Optional[dict] = None,
              profile_variables: Optional[list] = None,
              system_variables: Optional[list] = None,
              study: Optional[str] = None):
        """
        Starts running a nodal analysis simulation, returning the simulation id
        immediately which can be used later to check the status and get the results
        If the nodal analysis simulation task does not exist in the study, a new one 
        will be created.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the nodal analysis simulation task.
        parameters : dict
            Optional. The parameters and respective values to set.
        nodal_point_settings: dict
            Optional. The settings for nodal point to be created. The new nodal point is 
            applied to the existing or newly created nodal analysis task.  
        profile_variables : list
            Optional. The list of profile variables to be returned with the
            simulation profile results. If omitted then all the possible
            profile variables are returned.
        system_variables : list
            Optional. The list of system variables to be returned with the
            simulation system results. If omitted then all the possible
            system variables are returned.
        study : str
            Optional. The name of the study. If no name is specified and there is one default study,
            the default study will be used. If there are multiple studies in the model, study name is required.

        Returns
        -------
        str
            The simulation id, which can be used to access simulation status and get the results.

        Examples
        --------
        >>> sim_id = model.tasks.nodalanalysis.start("Well 1",
                parameters={
                    Parameters.NodalAnalysisSimulation.OUTLETPRESSURE: 3000,
                    Parameters.NodalAnalysisSimulation.BRANCHTERMINATOR: "Choke"
                },
                nodal_point_settings = {
                    Parameters.NodalPoint.NODALTYPE: Constants.NodalPointType.SURFACE,
                    Parameters.NodalPoint.EQUIPMENT: 'Choke',
                    Parameters.NodalPoint.NAME: 'NA4'
                },
                profile_variables=OutputVariables.Profile.GAS_FIELD,
                system_variables=OutputVariables.System.GAS_FIELD)

        """
        return _start_na_simulation(self._model, producer=producer, parameters=parameters, inlet_conditions=inlet_conditions,
                                    nodal_point_settings=nodal_point_settings, profile_variables=profile_variables,
                                    system_variables=system_variables, study=study)

    def generate_engine_files(self,
                              producer,
                              folder_path: Optional[str] = None,
                              study: Optional[str] = None) -> List[str]:
        """
        Create engine files for the specified study.

        Generate the engine file(s) for the requested study. The files are written
        to the specified folder, or to the current model folder if one is not given.

        Parameters
        ----------
        producer : str
            Required. The name of the producer for the Nodal analysis simulation task.
        folder_path : str
            Optional. The folder location where the generated files are written to.
            If not specified, the files will be written to current pipesim model folder.
        study : str
            Optional. The study name.

        Returns
        -------
        List[str]
            The list of engine files generated.

        Examples
        --------
        >>> engine_files = model.tasks.nodalanalysis.generate_engine_files(
                                    producer="Well 1")
        >>> engine_files = model.tasks.nodalanalysis.generate_engine_files(
                                    producer="Well 1", 
                                    folder_path="D:\\Temp")
        >>> engine_files = model.tasks.nodalanalysis.generate_engine_files(
                                    producer="Well 1", 
                                    folder_path="D:\\Temp",
                                    study="Study 1")
        """

        producer_obj = get_single_branch_task_producer(producer, self._model)
        na_sim_task = get_or_create_na_operation(self._model, producer_obj, study, nodal_point_settings=None)
        operation_context = self._model._catalog.lookup_context_by_node(na_sim_task)

        if not folder_path:
            folder_path = os.path.dirname(os.path.realpath(self._model._model_file))

        return generate(self._model._catalog, operation_context, folder_path)
